Disassembly Listing for pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody
Generated From:
C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/dist/free/production/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X.production.elf
Mar 15, 2023 2:58:27 PM

---  C:/Users/c63290/AppData/Local/Temp/xcAsogc.s  ------------------------------------------------------
0A9A  0064     CLRWDT
0A9B  0180     CLRF INDF0
0A9C  3101     ADDFSR 0, 1
0A9D  0B89     DECFSZ WREG, F
0A9E  2A9B     GOTO 0x29B
0A9F  3400     RETLW 0x0
0026  3020     MOVLW 0x20
0027  0084     MOVWF FSR0
0028  3000     MOVLW 0x0
0029  0085     MOVWF FSR0H
002A  3026     MOVLW 0x26
002B  318A     MOVLP 0xA
002E  107E     BCF btemp, 0x0
002F  0140     MOVLB 0x0
0030  3180     MOVLP 0x0
---  C:/Program Files/Microchip/xc8/v2.36/pic/sources/c99/common/ltdiv.c  -------------------------------
1:             // short long unsigned unsigned division
2:             
3:             __uint24
4:             #ifdef __PICC__
5:             __ltdiv(__uint24 divisor, __uint24 dividend)
6:             #else
7:             __ltdiv(__uint24 dividend, __uint24 divisor)
8:             #endif
9:             {
10:            	__uint24	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
0FB4  3000     MOVLW 0x0
0FB5  00F7     MOVWF readVal
0FB6  3000     MOVLW 0x0
0FB7  00F8     MOVWF pulse_countH
0FB8  3000     MOVLW 0x0
0FB9  00F9     MOVWF readValLow
14:            	if(divisor != 0) {
0FBA  0872     MOVF number, W
0FBB  0471     IORWF str, W
0FBC  0470     IORWF __pcstackCOMMON, W
0FBD  1903     BTFSC STATUS, 0x2
0FBE  2FC0     GOTO 0x7C0
0FBF  2FC1     GOTO 0x7C1
0FC0  2FF9     GOTO 0x7F9
15:            		counter = 1;
0FC1  01FA     CLRF readValHigh
0FC2  0AFA     INCF readValHigh, F
16:            		while((divisor & (__uint24)0x800000UL) == 0) {
0FC3  2FCE     GOTO 0x7CE
0FCE  1FF2     BTFSS number, 0x7
0FCF  2FD1     GOTO 0x7D1
0FD0  2FD2     GOTO 0x7D2
0FD1  2FC4     GOTO 0x7C4
17:            			divisor <<= 1;
0FC4  3001     MOVLW 0x1
0FC5  35F0     LSLF __pcstackCOMMON, F
0FC6  0DF1     RLF str, F
0FC7  0DF2     RLF number, F
0FC8  0B89     DECFSZ WREG, F
0FC9  2FC5     GOTO 0x7C5
18:            			counter++;
0FCA  3001     MOVLW 0x1
0FCB  00F6     MOVWF period_countL
0FCC  0876     MOVF period_countL, W
0FCD  07FA     ADDWF readValHigh, F
19:            		}
20:            		do {
21:            			quotient <<= 1;
0FD2  3001     MOVLW 0x1
0FD3  35F7     LSLF readVal, F
0FD4  0DF8     RLF pulse_countH, F
0FD5  0DF9     RLF readValLow, F
0FD6  0B89     DECFSZ WREG, F
0FD7  2FD3     GOTO 0x7D3
22:            			if(divisor <= dividend) {
0FD8  0872     MOVF number, W
0FD9  0275     SUBWF period_countH, W
0FDA  1D03     BTFSS STATUS, 0x2
0FDB  2FE2     GOTO 0x7E2
0FDC  0871     MOVF str, W
0FDD  0274     SUBWF pulse_countL, W
0FDE  1D03     BTFSS STATUS, 0x2
0FDF  2FE2     GOTO 0x7E2
0FE0  0870     MOVF __pcstackCOMMON, W
0FE1  0273     SUBWF module, W
0FE2  1C03     BTFSS STATUS, 0x0
0FE3  2FE5     GOTO 0x7E5
0FE4  2FE6     GOTO 0x7E6
0FE5  2FED     GOTO 0x7ED
23:            				dividend -= divisor;
0FE6  0870     MOVF __pcstackCOMMON, W
0FE7  02F3     SUBWF module, F
0FE8  0871     MOVF str, W
0FE9  3BF4     SUBWFB pulse_countL, F
0FEA  0872     MOVF number, W
0FEB  3BF5     SUBWFB period_countH, F
24:            				quotient |= 1;
0FEC  1477     BSF readVal, 0x0
25:            			}
26:            			divisor >>= 1;
0FED  3001     MOVLW 0x1
0FEE  36F2     LSRF number, F
0FEF  0CF1     RRF str, F
0FF0  0CF0     RRF __pcstackCOMMON, F
0FF1  0B89     DECFSZ WREG, F
0FF2  2FEE     GOTO 0x7EE
27:            		} while(--counter != 0);
0FF3  3001     MOVLW 0x1
0FF4  02FA     SUBWF readValHigh, F
0FF5  1D03     BTFSS STATUS, 0x2
0FF6  2FF8     GOTO 0x7F8
0FF7  2FF9     GOTO 0x7F9
0FF8  2FD2     GOTO 0x7D2
28:            	}
29:            	return quotient;
0FF9  0877     MOVF readVal, W
0FFA  00F0     MOVWF __pcstackCOMMON
0FFB  0878     MOVF pulse_countH, W
0FFC  00F1     MOVWF str
0FFD  0879     MOVF readValLow, W
0FFE  00F2     MOVWF number
30:            }
0FFF  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/uart/src/eusart1.c
1:             /**
2:              * EUSART1 Generated Driver API Header File
3:              * 
4:              * @file eusart1.c
5:              * 
6:              * @ingroup eusart1
7:              * 
8:              * @brief This is the generated driver implementation file for the EUSART1 driver using CCL
9:              *
10:             * @version EUSART1 Driver Version 3.0.0
11:            */
12:            
13:            /*
14:            © [2023] Microchip Technology Inc. and its subsidiaries.
15:            
16:                Subject to your compliance with these terms, you may use Microchip 
17:                software and any derivatives exclusively with Microchip products. 
18:                You are responsible for complying with 3rd party license terms  
19:                applicable to your use of 3rd party software (including open source  
20:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
21:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
22:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
23:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
24:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
25:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
26:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
28:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
29:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
30:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
31:                THIS SOFTWARE.
32:            */
33:            
34:            /**
35:              Section: Included Files
36:            */
37:            #include "../eusart1.h"
38:            
39:            /**
40:              Section: Macro Declarations
41:            */
42:            
43:            /**
44:              Section: Driver Interface
45:             */
46:            
47:            const uart_drv_interface_t UART1 = {
48:                .Initialize = &EUSART1_Initialize,
49:                .Deinitialize = &EUSART1_Deinitialize,
50:                .Read = &EUSART1_Read,
51:                .Write = &EUSART1_Write,
52:                .IsRxReady = &EUSART1_IsRxReady,
53:                .IsTxReady = &EUSART1_IsTxReady,
54:                .IsTxDone = &EUSART1_IsTxDone,
55:                .TransmitEnable = &EUSART1_TransmitEnable,
56:                .TransmitDisable = &EUSART1_TransmitDisable,
57:                .AutoBaudSet = NULL,
58:                .AutoBaudQuery = NULL,
59:                .BRGCountSet = NULL,
60:                .BRGCountGet = NULL,
61:                .BaudRateSet = NULL,
62:                .BaudRateGet = NULL,
63:                .AutoBaudEventEnableGet = NULL,
64:                .ErrorGet = &EUSART1_ErrorGet,
65:                .TxCompleteCallbackRegister = NULL,
66:                .RxCompleteCallbackRegister = NULL,
67:                .TxCollisionCallbackRegister = NULL,
68:                .FramingErrorCallbackRegister = &EUSART1_FramingErrorCallbackRegister,
69:                .OverrunErrorCallbackRegister = &EUSART1_OverrunErrorCallbackRegister,
70:                .ParityErrorCallbackRegister = NULL,
71:                .EventCallbackRegister = NULL,
72:            };
73:            
74:            /**
75:              Section: EUSART1 variables
76:            */
77:            volatile eusart1_status_t eusart1RxLastError;
78:            
79:            /**
80:              Section: EUSART1 APIs
81:            */
82:            
83:            void (*EUSART1_FramingErrorHandler)(void);
84:            void (*EUSART1_OverrunErrorHandler)(void);
85:            
86:            static void EUSART1_DefaultFramingErrorCallback(void);
87:            static void EUSART1_DefaultOverrunErrorCallback(void);
88:            
89:            
90:            /**
91:              Section: EUSART1  APIs
92:            */
93:            
94:            void EUSART1_Initialize(void)
95:            {
96:                // Set the EUSART1 module to the options selected in the user interface.
97:            
98:                //ABDEN disabled; WUE disabled; BRG16 16bit_generator; SCKP Non-Inverted; 
99:                BAUD1CON = 0x48; 
0D60  3048     MOVLW 0x48
0D61  014C     MOVLB 0xC
0D62  0092     MOVWF BAUD1CON
100:               //ADDEN disabled; CREN enabled; SREN disabled; RX9 8-bit; SPEN enabled; 
101:               RC1STA = 0x90; 
0D63  3090     MOVLW 0x90
0D64  0090     MOVWF RC1STA
102:               //TX9D 0x0; BRGH hi_speed; SENDB sync_break_complete; SYNC asynchronous; TXEN enabled; TX9 8-bit; CSRC client; 
103:               TX1STA = 0x26; 
0D65  3026     MOVLW 0x26
0D66  0091     MOVWF TX1STA
104:               //SPBRGL 68; 
105:               SP1BRGL = 0x44; 
0D67  3044     MOVLW 0x44
0D68  008E     MOVWF SP1BRG
106:               //SPBRGH 0; 
107:               SP1BRGH = 0x0; 
0D69  018F     CLRF SP1BRGH
108:           
109:               EUSART1_FramingErrorCallbackRegister(EUSART1_DefaultFramingErrorCallback);
0D6A  3000     MOVLW 0x0
0D6B  00F0     MOVWF 0x670
0D6C  3000     MOVLW 0x0
0D6D  00F1     MOVWF 0x671
0D6E  318B     MOVLP 0xB
0D6F  2311     CALL 0x311
0D70  318D     MOVLP 0xD
110:               EUSART1_OverrunErrorCallbackRegister(EUSART1_DefaultOverrunErrorCallback);
0D71  3000     MOVLW 0x0
0D72  00F0     MOVWF 0x670
0D73  3000     MOVLW 0x0
0D74  00F1     MOVWF 0x671
0D75  318B     MOVLP 0xB
0D76  231D     CALL 0x31D
0D77  318D     MOVLP 0xD
111:               eusart1RxLastError.status = 0;  
0D78  0140     MOVLB 0x0
0D79  01BE     CLRF eusart1RxLastError
0D7A  01BF     CLRF 0x3F
112:           
113:           }
0D7B  0008     RETURN
114:           
115:           void EUSART1_Deinitialize(void)
116:           {
117:               BAUD1CON = 0x00;
118:               RC1STA = 0x00;
119:               TX1STA = 0x00;
120:               SP1BRGL = 0x00;
121:               SP1BRGH = 0x00;
122:           }
123:           
124:           inline void EUSART1_Enable(void)
125:           {
126:               RC1STAbits.SPEN = 1;
127:           
128:           }
129:           
130:           inline void EUSART1_Disable(void)
131:           {
132:               RC1STAbits.SPEN = 0;
133:           }
134:           
135:           inline void EUSART1_TransmitEnable(void)
136:           {
137:               TX1STAbits.TXEN = 1;
138:           }
139:           
140:           inline void EUSART1_TransmitDisable(void)
141:           {
142:               TX1STAbits.TXEN = 0;
143:           }
144:           
145:           inline void EUSART1_ReceiveEnable(void)
146:           {
147:               RC1STAbits.CREN = 1;
148:           }
149:           
150:           inline void EUSART1_ReceiveDisable(void)
151:           {
152:               RC1STAbits.CREN = 0;
153:           }
154:           
155:           inline void EUSART1_SendBreakControlEnable(void)
156:           {
157:               TX1STAbits.SENDB = 1;
158:           }
159:           
160:           inline void EUSART1_SendBreakControlDisable(void)
161:           {
162:               TX1STAbits.SENDB = 0;
163:           }
164:           
165:           bool EUSART1_IsRxReady(void)
166:           {
167:               return (bool)(PIR3bits.RC1IF);
168:           }
169:           
170:           bool EUSART1_IsTxReady(void)
171:           {
172:               return (bool)(PIR3bits.TX1IF && TX1STAbits.TXEN);
0B52  01F0     CLRF __pcstackCOMMON
0B53  0141     MOVLB 0x1
0B54  1D0F     BTFSS PIR3, 0x2
0B55  2B57     GOTO 0x357
0B56  2B58     GOTO 0x358
0B57  2B5F     GOTO 0x35F
0B58  014C     MOVLB 0xC
0B59  1E91     BTFSS TX1STA, 0x5
0B5A  2B5C     GOTO 0x35C
0B5B  2B5D     GOTO 0x35D
0B5C  2B5F     GOTO 0x35F
0B5D  01F0     CLRF 0x670
0B5E  0AF0     INCF 0x670, F
0B5F  0870     MOVF 0x670, W
173:           }
0B60  0008     RETURN
174:           
175:           bool EUSART1_IsTxDone(void)
176:           {
177:               return TX1STAbits.TRMT;
178:           }
179:           
180:           size_t EUSART1_ErrorGet(void)
181:           {
182:               return eusart1RxLastError.status;
183:           }
184:           
185:           uint8_t EUSART1_Read(void)
186:           {
187:               eusart1RxLastError.status = 0;
188:               if(RC1STAbits.OERR)
189:               {
190:                   eusart1RxLastError.oerr = 1;
191:                   if(NULL != EUSART1_OverrunErrorHandler)
192:                   {
193:                       EUSART1_OverrunErrorHandler();
194:                   }   
195:               }
196:               if(RC1STAbits.FERR)
197:               {
198:                   eusart1RxLastError.ferr = 1;
199:                   if(NULL != EUSART1_FramingErrorHandler)
200:                   {
201:                       EUSART1_FramingErrorHandler();
202:                   }   
203:               }
204:               return RC1REG;
205:           }
206:           
207:           void EUSART1_Write(uint8_t txData)
208:           {
209:               TX1REG = txData;
0A49  0870     MOVF 0x670, W
0A4A  014C     MOVLB 0xC
0A4B  008D     MOVWF TX1REG
210:           }
0A4C  0008     RETURN
211:           
212:           static void EUSART1_DefaultFramingErrorCallback(void)
213:           {
214:               
215:           }
216:           
217:           static void EUSART1_DefaultOverrunErrorCallback(void)
218:           {
219:               //Continuous Receive must be cleared to clear Overrun Error else Rx will not receive upcoming bytes
220:               RC1STAbits.CREN = 0;
221:               RC1STAbits.CREN = 1;
222:           }
223:           
224:           void EUSART1_FramingErrorCallbackRegister(void (* callbackHandler)(void))
225:           {
226:               if(NULL != callbackHandler)
0B11  0870     MOVF 0x670, W
0B12  0471     IORWF 0x671, W
0B13  1903     BTFSC STATUS, 0x2
0B14  2B16     GOTO 0x316
0B15  2B17     GOTO 0x317
0B16  2B1C     GOTO 0x31C
227:               {
228:                   EUSART1_FramingErrorHandler = callbackHandler;
0B17  0871     MOVF 0x671, W
0B18  0140     MOVLB 0x0
0B19  00BD     MOVWF 0x3D
0B1A  0870     MOVF __pcstackCOMMON, W
0B1B  00BC     MOVWF EUSART1_FramingErrorHandler
229:               }
230:           }
0B1C  0008     RETURN
231:           
232:           void EUSART1_OverrunErrorCallbackRegister(void (* callbackHandler)(void))
233:           {
234:               if(NULL != callbackHandler)
0B1D  0870     MOVF __pcstackCOMMON, W
0B1E  0471     IORWF str, W
0B1F  1903     BTFSC STATUS, 0x2
0B20  2B22     GOTO 0x322
0B21  2B23     GOTO 0x323
0B22  2B28     GOTO 0x328
235:               {
236:                   EUSART1_OverrunErrorHandler = callbackHandler;
0B23  0871     MOVF str, W
0B24  0140     MOVLB 0x0
0B25  00BB     MOVWF 0x3B
0B26  0870     MOVF __pcstackCOMMON, W
0B27  00BA     MOVWF EUSART1_OverrunErrorHandler
237:               }    
238:           }
0B28  0008     RETURN
239:           
240:           // Added by Application Engineer (NOT GENERATED FROM MCC/MELODY)
241:           void EUSART1_sendString(const char *str)
242:           {
243:               while(*str)
0EB3  2ECB     GOTO 0x6CB
0ECB  0871     MOVF str, W
0ECC  0084     MOVWF FSR0
0ECD  0872     MOVF number, W
0ECE  0085     MOVWF FSR0H
0ECF  0012     MOVIW FSR0++
0ED0  1D03     BTFSS STATUS, 0x2
0ED1  2ED3     GOTO 0x6D3
0ED2  2ED4     GOTO 0x6D4
0ED3  2EB4     GOTO 0x6B4
244:               {
245:                   while (!(EUSART1_IsTxReady()));
0EB4  318B     MOVLP 0xB
0EB5  2352     CALL 0x352
0EB6  318E     MOVLP 0xE
0EB7  3A00     XORLW 0x0
0EB8  1903     BTFSC STATUS, 0x2
0EB9  2EBB     GOTO 0x6BB
0EBA  2EBC     GOTO 0x6BC
0EBB  2EB4     GOTO 0x6B4
246:                   EUSART1_Write(*str++);
0EBC  0871     MOVF str, W
0EBD  0084     MOVWF FSR0
0EBE  0872     MOVF number, W
0EBF  0085     MOVWF FSR0H
0EC0  0800     MOVF INDF0, W
0EC1  00F3     MOVWF module
0EC2  0873     MOVF module, W
0EC3  00F0     MOVWF __pcstackCOMMON
0EC4  318A     MOVLP 0xA
0EC5  2249     CALL 0x249
0EC6  318E     MOVLP 0xE
0EC7  3001     MOVLW 0x1
0EC8  07F1     ADDWF str, F
0EC9  3000     MOVLW 0x0
0ECA  3DF2     ADDWFC number, F
0ECB  0871     MOVF str, W
0ECC  0084     MOVWF FSR0
0ECD  0872     MOVF number, W
0ECE  0085     MOVWF FSR0H
0ECF  0012     MOVIW FSR0++
0ED0  1D03     BTFSS STATUS, 0x2
0ED1  2ED3     GOTO 0x6D3
0ED2  2ED4     GOTO 0x6D4
0ED3  2EB4     GOTO 0x6B4
247:               }
248:           }
0ED4  0008     RETURN
249:           
250:           void EUSART1_sendInt(uint8_t number){
0B90  00F2     MOVWF number
251:               while (!(EUSART1_IsTxReady()));
0B91  318B     MOVLP 0xB
0B92  2352     CALL 0x352
0B93  318B     MOVLP 0xB
0B94  3A00     XORLW 0x0
0B95  1903     BTFSC STATUS, 0x2
0B96  2B98     GOTO 0x398
0B97  2B99     GOTO 0x399
0B98  2B91     GOTO 0x391
252:               EUSART1_Write(number);
0B99  0872     MOVF number, W
0B9A  00F1     MOVWF str
0B9B  0871     MOVF str, W
0B9C  00F0     MOVWF __pcstackCOMMON
0B9D  318A     MOVLP 0xA
0B9E  2249     CALL 0x249
0B9F  318B     MOVLP 0xB
253:           }
0BA0  0008     RETURN
254:           
255:           void UART_test(void){
256:               EUSART1_sendString("Hello World!\r\n");
257:           }
258:           
259:           void EUSART1_sendAllData(uint8_t pulse_countH, uint8_t pulse_countL, uint8_t period_countH, uint8_t period_countL,  uint8_t duty_cycle){
0ED5  00F8     MOVWF pulse_countH
260:               EUSART1_sendString("\nPULSE: ");
0ED6  3047     MOVLW 0x47
0ED7  00F1     MOVWF str
0ED8  3091     MOVLW 0x91
0ED9  00F2     MOVWF number
0EDA  318E     MOVLP 0xE
0EDB  26B3     CALL 0x6B3
0EDC  318E     MOVLP 0xE
261:               EUSART1_sendInt(pulse_countH); 
0EDD  0878     MOVF pulse_countH, W
0EDE  318B     MOVLP 0xB
0EDF  2390     CALL 0x390
0EE0  318E     MOVLP 0xE
262:               EUSART1_sendInt(pulse_countL); 
0EE1  0874     MOVF pulse_countL, W
0EE2  318B     MOVLP 0xB
0EE3  2390     CALL 0x390
0EE4  318E     MOVLP 0xE
263:               EUSART1_sendString("\nPD: ");
0EE5  305E     MOVLW 0x5E
0EE6  00F1     MOVWF str
0EE7  3091     MOVLW 0x91
0EE8  00F2     MOVWF number
0EE9  318E     MOVLP 0xE
0EEA  26B3     CALL 0x6B3
0EEB  318E     MOVLP 0xE
264:               EUSART1_sendInt(period_countH);
0EEC  0875     MOVF period_countH, W
0EED  318B     MOVLP 0xB
0EEE  2390     CALL 0x390
0EEF  318E     MOVLP 0xE
265:               EUSART1_sendInt(period_countL);
0EF0  0876     MOVF period_countL, W
0EF1  318B     MOVLP 0xB
0EF2  2390     CALL 0x390
0EF3  318E     MOVLP 0xE
266:               EUSART1_sendString("\nDC: ");
0EF4  3058     MOVLW 0x58
0EF5  00F1     MOVWF str
0EF6  3091     MOVLW 0x91
0EF7  00F2     MOVWF number
0EF8  318E     MOVLP 0xE
0EF9  26B3     CALL 0x6B3
0EFA  318E     MOVLP 0xE
267:               EUSART1_sendInt(duty_cycle);
0EFB  0877     MOVF readVal, W
0EFC  318B     MOVLP 0xB
0EFD  2390     CALL 0x390
0EFE  318E     MOVLP 0xE
268:           }
0EFF  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/timer/src/tmr2.c
1:             /**
2:              * TMR2 Generated Driver File
3:              *
4:              * @file tmr2.c
5:              * 
6:              * @ingroup  tmr2
7:              * 
8:              * @brief This is the generated driver implementation file for the TMR2 module.
9:              *
10:             * @version TMR2 Driver Version 3.0.1
11:             */
12:            
13:            /*
14:            © [2023] Microchip Technology Inc. and its subsidiaries.
15:            
16:                Subject to your compliance with these terms, you may use Microchip 
17:                software and any derivatives exclusively with Microchip products. 
18:                You are responsible for complying with 3rd party license terms  
19:                applicable to your use of 3rd party software (including open source  
20:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
21:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
22:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
23:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
24:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
25:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
26:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
28:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
29:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
30:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
31:                THIS SOFTWARE.
32:            */
33:            
34:            /**
35:              Section: Included Files
36:            */
37:            
38:            #include <xc.h>
39:            #include "../tmr2.h"
40:            
41:            const struct TMR_INTERFACE Timer2 = {
42:                .Initialize = Timer2_Initialize,
43:                .Start = Timer2_Start,
44:                .Stop = Timer2_Stop,
45:                .PeriodCountSet = Timer2_PeriodCountSet,
46:                .TimeoutCallbackRegister = Timer2_OverflowCallbackRegister,
47:                .Tasks = Timer2_Tasks
48:            };
49:            
50:            static void (*Timer2_OverflowCallback)(void);
51:            static void Timer2_DefaultOverflowCallback(void);
52:            
53:            /**
54:              Section: TMR2 APIs
55:            */
56:            
57:            void Timer2_Initialize(void){
58:            
59:                // Set TMR2 to the options selected in the User Interface
60:                // TCS LFINTOSC; 
61:                T2CLKCON = 0x4;
0C78  3004     MOVLW 0x4
0C79  0146     MOVLB 0x6
0C7A  0090     MOVWF T2CLKCON
62:                // TMODE Starts on falling edge on TMR2_ers; TCKSYNC Not Synchronized; TCKPOL Rising Edge; TPSYNC Not Synchronized; 
63:                T2HLT = 0x12;
0C7B  3012     MOVLW 0x12
0C7C  008F     MOVWF T2HLT
64:                // TRSEL T2CKIPPS pin; 
65:                T2RST = 0x0;
0C7D  0191     CLRF T2RST
66:                // PR 96; 
67:                T2PR = 0x60;
0C7E  3060     MOVLW 0x60
0C7F  008D     MOVWF T2PR
68:                // TMR 0x0; 
69:                T2TMR = 0x0;
0C80  018C     CLRF T2TMR
70:            
71:                // Set default overflow callback
72:                Timer2_OverflowCallbackRegister(Timer2_DefaultOverflowCallback);
0C81  3000     MOVLW 0x0
0C82  00F0     MOVWF 0x370
0C83  3000     MOVLW 0x0
0C84  00F1     MOVWF 0x371
0C85  318A     MOVLP 0xA
0C86  2294     CALL 0x294
0C87  318C     MOVLP 0xC
73:            
74:                // Clearing IF flag.
75:                 PIR1bits.TMR2IF = 0;
0C88  0141     MOVLB 0x1
0C89  138D     BCF PIR1, 0x7
76:                // TCKPS 1:64; TMRON on; TOUTPS 1:1; 
77:                T2CON = 0xE0;
0C8A  30E0     MOVLW 0xE0
0C8B  0146     MOVLB 0x6
0C8C  008E     MOVWF T2CON
78:            }
0C8D  0008     RETURN
79:            
80:            void Timer2_ModeSet(Timer2_HLT_MODE mode)
81:            {
82:               // Configure different types HLT mode
83:                T2HLTbits.T2MODE = mode;
84:            }
85:            
86:            void Timer2_ExtResetSourceSet(Timer2_HLT_EXT_RESET_SOURCE reset)
87:            {
88:                //Configure different types of HLT external reset source
89:                T2RSTbits.T2RSEL = reset;
90:            }
91:            
92:            void Timer2_Start(void)
93:            {
94:                // Start the Timer by writing to TMRxON bit
95:                T2CONbits.TMR2ON = 1;
96:            }
97:            
98:            void Timer2_Stop(void)
99:            {
100:               // Stop the Timer by writing to TMRxON bit
101:               T2CONbits.TMR2ON = 0;
102:           }
103:           
104:           uint8_t Timer2_Read(void)
105:           {
106:               uint8_t readVal;
107:               readVal = TMR2;
108:               return readVal;
109:           }
110:           
111:           void Timer2_Write(uint8_t timerVal)
112:           {
113:               // Write to the Timer2 register
114:               TMR2 = timerVal;;
115:           }
116:           
117:           void Timer2_PeriodCountSet(size_t periodVal)
118:           {
119:              PR2 = (uint8_t) periodVal;
120:           }
121:           
122:           void Timer2_OverflowCallbackRegister(void (* InterruptHandler)(void)){
123:               Timer2_OverflowCallback = InterruptHandler;
0A94  0871     MOVF 0x371, W
0A95  0140     MOVLB 0x0
0A96  00C1     MOVWF 0x41
0A97  0870     MOVF __pcstackCOMMON, W
0A98  00C0     MOVWF Timer2_OverflowCallback
124:           }
0A99  0008     RETURN
125:           
126:           static void Timer2_DefaultOverflowCallback(void){
127:               // add your TMR2 interrupt custom code
128:               // or set custom function using Timer2_OverflowCallbackRegister()
129:           }
130:           
131:           void Timer2_Tasks(void)
132:           {
133:               if(PIR1bits.TMR2IF)
134:               {
135:                   // Clearing IF flag.
136:                   PIR1bits.TMR2IF = 0;
137:                   Timer2_OverflowCallback();
138:               }
139:           }
140:           
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/system/src/system.c
1:             /**
2:              * System Driver Source File
3:              * 
4:              * @file system.c
5:              * 
6:              * @ingroup systemdriver
7:              * 
8:              * @brief This is the generated driver implementation file for the System Driver.
9:              *
10:             * @version Driver Version 1.0.0
11:            */
12:            
13:            /*
14:            © [2023] Microchip Technology Inc. and its subsidiaries.
15:            
16:                Subject to your compliance with these terms, you may use Microchip 
17:                software and any derivatives exclusively with Microchip products. 
18:                You are responsible for complying with 3rd party license terms  
19:                applicable to your use of 3rd party software (including open source  
20:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
21:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
22:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
23:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
24:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
25:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
26:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
28:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
29:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
30:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
31:                THIS SOFTWARE.
32:            */
33:            
34:             /**
35:               Section: Included Files
36:             */
37:            #include "../system.h"
38:            
39:            /**
40:              Section: Driver APIs
41:            */
42:            
43:            void SYSTEM_Initialize(void)
44:            {
45:                CLOCK_Initialize();
0C11  318A     MOVLP 0xA
0C12  22E3     CALL 0x2E3
0C13  318C     MOVLP 0xC
46:                PIN_MANAGER_Initialize();
0C14  3187     MOVLP 0x7
0C15  271C     CALL 0x71C
0C16  318C     MOVLP 0xC
47:                CLC4_Initialize();
0C17  318D     MOVLP 0xD
0C18  25B6     CALL 0x5B6
0C19  318C     MOVLP 0xC
48:                EUSART1_Initialize();
0C1A  318D     MOVLP 0xD
0C1B  2560     CALL 0x560
0C1C  318C     MOVLP 0xC
49:                Timer2_Initialize();
0C1D  318C     MOVLP 0xC
0C1E  2478     CALL 0x478
0C1F  318C     MOVLP 0xC
50:                INTERRUPT_Initialize();
0C20  318A     MOVLP 0xA
0C21  22EE     CALL 0x2EE
0C22  318C     MOVLP 0xC
51:            }
0C23  0008     RETURN
52:            
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/system/src/pins.c
1:             /**
2:              * Generated Driver File
3:              * 
4:              * @file pins.c
5:              * 
6:              * @ingroup  pinsdriver
7:              * 
8:              * @brief This is generated driver implementation for pins. 
9:              *        This file provides implementations for pin APIs for all pins selected in the GUI.
10:             *
11:             * @version Driver Version 3.0.0
12:            */
13:            
14:            /*
15:            © [2023] Microchip Technology Inc. and its subsidiaries.
16:            
17:                Subject to your compliance with these terms, you may use Microchip 
18:                software and any derivatives exclusively with Microchip products. 
19:                You are responsible for complying with 3rd party license terms  
20:                applicable to your use of 3rd party software (including open source  
21:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
22:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
23:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
24:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
25:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
26:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
27:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
28:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
29:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
30:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
31:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
32:                THIS SOFTWARE.
33:            */
34:            
35:            #include "../pins.h"
36:            
37:            
38:            void PIN_MANAGER_Initialize(void)
39:            {
40:               /**
41:                LATx registers
42:                */
43:                LATA = 0x0;
071C  0140     MOVLB 0x0
071D  0198     CLRF LATA
44:                LATB = 0x0;
071E  0199     CLRF LATB
45:                LATC = 0x0;
071F  019A     CLRF LATC
46:                LATD = 0x0;
0720  019B     CLRF LATD
47:                LATE = 0x0;
0721  019C     CLRF LATE
48:            
49:                /**
50:                TRISx registers
51:                */
52:                TRISA = 0xFF;
0722  30FF     MOVLW 0xFF
0723  0092     MOVWF TRISA
53:                TRISB = 0xFF;
0724  30FF     MOVLW 0xFF
0725  0093     MOVWF TRISB
54:                TRISC = 0xBF;
0726  30BF     MOVLW 0xBF
0727  0094     MOVWF TRISC
55:                TRISD = 0xFF;
0728  30FF     MOVLW 0xFF
0729  0095     MOVWF TRISD
56:                TRISE = 0xF;
072A  300F     MOVLW 0xF
072B  0096     MOVWF TRISE
57:            
58:                /**
59:                ANSELx registers
60:                */
61:                ANSELA = 0xFE;
072C  30FE     MOVLW 0xFE
072D  017D     MOVLB 0x3D
072E  008C     MOVWF ANSELA
62:                ANSELB = 0xDF;
072F  30DF     MOVLW 0xDF
0730  0096     MOVWF ANSELB
63:                ANSELC = 0x3F;
0731  303F     MOVLW 0x3F
0732  00A0     MOVWF ANSELC
64:                ANSELD = 0xFF;
0733  30FF     MOVLW 0xFF
0734  00AA     MOVWF ANSELD
65:                ANSELE = 0x7;
0735  3007     MOVLW 0x7
0736  00B4     MOVWF ANSELE
66:            
67:                /**
68:                WPUx registers
69:                */
70:                WPUA = 0x1;
0737  3001     MOVLW 0x1
0738  008D     MOVWF WPUA
71:                WPUB = 0x0;
0739  0197     CLRF WPUB
72:                WPUC = 0x0;
073A  01A1     CLRF WPUC
73:                WPUD = 0x0;
073B  01AB     CLRF WPUD
74:                WPUE = 0x0;
073C  01B5     CLRF WPUE
75:              
76:            
77:                /**
78:                APFCONx registers
79:                */
80:            
81:                /**
82:                ODx registers
83:                */
84:               
85:                ODCONA = 0x0;
073D  018E     CLRF ODCONA
86:                ODCONB = 0x0;
073E  0198     CLRF ODCONB
87:                ODCONC = 0x0;
073F  01A2     CLRF ODCONC
88:                ODCOND = 0x0;
0740  01AC     CLRF ODCOND
89:                ODCONE = 0x0;
0741  01B6     CLRF ODCONE
90:                /**
91:                SLRCONx registers
92:                */
93:                SLRCONA = 0xFF;
0742  30FF     MOVLW 0xFF
0743  008F     MOVWF SLRCONA
94:                SLRCONB = 0xFF;
0744  30FF     MOVLW 0xFF
0745  0099     MOVWF SLRCONB
95:                SLRCONC = 0xFF;
0746  30FF     MOVLW 0xFF
0747  00A3     MOVWF SLRCONC
96:                SLRCOND = 0xFF;
0748  30FF     MOVLW 0xFF
0749  00AD     MOVWF SLRCOND
97:                SLRCONE = 0x7;
074A  3007     MOVLW 0x7
074B  00B7     MOVWF SLRCONE
98:                /**
99:                INLVLx registers
100:               */
101:               INLVLA = 0xFF;
074C  30FF     MOVLW 0xFF
074D  0090     MOVWF INLVLA
102:               INLVLB = 0xFF;
074E  30FF     MOVLW 0xFF
074F  009A     MOVWF INLVLB
103:               INLVLC = 0xFF;
0750  30FF     MOVLW 0xFF
0751  00A4     MOVWF INLVLC
104:               INLVLD = 0xFF;
0752  30FF     MOVLW 0xFF
0753  00AE     MOVWF INLVLD
105:               INLVLE = 0xF;
0754  300F     MOVLW 0xF
0755  00B8     MOVWF INLVLE
106:           
107:               /**
108:               PPS registers
109:               */
110:               T2INPPS = 0x0; //RA0->TMR2:T2IN;
0756  017C     MOVLB 0x3C
0757  0199     CLRF T2INPPS
111:               RX1PPS = 0x17; //RC7->EUSART1:RX1;
0758  3017     MOVLW 0x17
0759  00C1     MOVWF RX1PPS
112:               RC6PPS = 0x0E;  //RC6->EUSART1:TX1;
075A  300E     MOVLW 0xE
075B  017B     MOVLB 0x3B
075C  00A2     MOVWF RC6PPS
113:           
114:              /**
115:               IOCx registers 
116:               */
117:               IOCAP = 0x0;
075D  017D     MOVLB 0x3D
075E  0191     CLRF IOCAP
118:               IOCAN = 0x0;
075F  0192     CLRF IOCAN
119:               IOCAF = 0x0;
0760  0193     CLRF IOCAF
120:               IOCBP = 0x0;
0761  019B     CLRF IOCBP
121:               IOCBN = 0x0;
0762  019C     CLRF IOCBN
122:               IOCBF = 0x0;
0763  019D     CLRF IOCBF
123:               IOCCP = 0x0;
0764  01A5     CLRF IOCCP
124:               IOCCN = 0x0;
0765  01A6     CLRF IOCCN
125:               IOCCF = 0x0;
0766  01A7     CLRF IOCCF
126:               IOCEP = 0x0;
0767  01B9     CLRF IOCEP
127:               IOCEN = 0x0;
0768  01BA     CLRF IOCEN
128:               IOCEF = 0x0;
0769  01BB     CLRF IOCEF
129:           
130:           
131:           }
076A  0008     RETURN
132:             
133:           void PIN_MANAGER_IOC(void)
134:           {
135:           }
0003  0008     RETURN
136:           /**
137:            End of File
138:           */
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/system/src/interrupt.c
1:             /**
2:              * Interrupt Manager Generated Driver File
3:              *
4:              * @file interrupt.c
5:              * 
6:              * @ingroup interrupt 
7:              * 
8:              * @brief This file contains the driver code for Interrupt Manager.
9:              * 
10:             * @version Interrupt Manager Driver Version 2.0.4
11:            */
12:            
13:            /*
14:            © [2023] Microchip Technology Inc. and its subsidiaries.
15:            
16:                Subject to your compliance with these terms, you may use Microchip 
17:                software and any derivatives exclusively with Microchip products. 
18:                You are responsible for complying with 3rd party license terms  
19:                applicable to your use of 3rd party software (including open source  
20:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
21:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
22:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
23:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
24:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
25:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
26:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
28:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
29:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
30:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
31:                THIS SOFTWARE.
32:            */
33:            
34:            #include "../../system/interrupt.h"
35:            #include "../../system/system.h"
36:            #include "../pins.h"
37:            
38:            void (*INT_InterruptHandler)(void);
39:            
40:            void  INTERRUPT_Initialize (void)
41:            {
42:                // Clear the interrupt flag
43:                // Set the external interrupt edge detect
44:                EXT_INT_InterruptFlagClear();   
0AEE  0141     MOVLB 0x1
0AEF  100C     BCF PIR0, 0x0
45:                EXT_INT_risingEdgeSet();
0AF0  140B     BSF INTCON, 0x0
46:                // Set Default Interrupt Handler
47:                INT_SetInterruptHandler(INT_DefaultInterruptHandler);
0AF1  3000     MOVLW 0x0
0AF2  00F0     MOVWF 0xF0
0AF3  3000     MOVLW 0x0
0AF4  00F1     MOVWF 0xF1
0AF5  318A     MOVLP 0xA
0AF6  228E     CALL 0x28E
0AF7  318A     MOVLP 0xA
48:                // EXT_INT_InterruptEnable();
49:            
50:            }
0AF8  0008     RETURN
51:            
52:            /**
53:             * @ingroup interrupt
54:             * @brief This routine services the ISRs of enabled interrupts and is called everytime an interrupt is triggered.
55:             * @pre Interrupt Manager is initialized.
56:             * @param void
57:             * @return void
58:             */
59:            void __interrupt() INTERRUPT_InterruptManager (void)
0004  147E     BSF 0xFE, 0x0
0005  3180     MOVLP 0x0
60:            {
61:                // GPIO pin interrupt on Change(IOC)
62:                if(PIE0bits.IOCIE == 1 && PIR0bits.IOCIF == 1)
0006  0141     MOVLB 0x1
0007  1E16     BTFSS PIE0, 0x4
0008  280A     GOTO 0xA
0009  280B     GOTO 0xB
000A  2812     GOTO 0x12
000B  1E0C     BTFSS PIR0, 0x4
000C  280E     GOTO 0xE
000D  280F     GOTO 0xF
000E  2812     GOTO 0x12
63:                {
64:                    PIN_MANAGER_IOC();
000F  3180     MOVLP 0x0
0010  2003     CALL 0x3
0011  3180     MOVLP 0x0
65:                }
66:                // interrupt handler
67:                if(INTCONbits.PEIE == 1)
0012  1F0B     BTFSS INTCON, 0x6
0013  2815     GOTO 0x15
0014  2816     GOTO 0x16
0015  2822     GOTO 0x22
68:                {
69:                    if(PIE3bits.CLC4IE == 1 && PIR3bits.CLC4IF == 1)
0016  0141     MOVLB 0x1
0017  1C99     BTFSS PIE3, 0x1
0018  281A     GOTO 0x1A
0019  281B     GOTO 0x1B
001A  2822     GOTO 0x22
001B  1C8F     BTFSS PIR3, 0x1
001C  281E     GOTO 0x1E
001D  281F     GOTO 0x1F
001E  2822     GOTO 0x22
70:                    {
71:                        CLC4_ISR();
001F  318A     MOVLP 0xA
0020  2264     CALL 0x264
0021  3180     MOVLP 0x0
72:                    } 
73:                    else
74:                    {
75:                        //Unhandled Interrupt
76:                    }
77:                }      
78:                else
79:                {
80:                    //Unhandled Interrupt
81:                }
82:            }
0022  107E     BCF 0xFE, 0x0
83:            
84:            void INT_ISR(void)
85:            {
86:                EXT_INT_InterruptFlagClear();
87:            
88:                // Callback function gets called everytime this ISR executes
89:                INT_CallBack();    
90:            }
91:            
92:            
93:            void INT_CallBack(void)
94:            {
95:                // Add your custom callback code here
96:                if(INT_InterruptHandler)
97:                {
98:                    INT_InterruptHandler();
99:                }
100:           }
101:           
102:           void INT_SetInterruptHandler(void (* InterruptHandler)(void)){
103:               INT_InterruptHandler = InterruptHandler;
0A8E  0871     MOVF 0xF1, W
0A8F  0140     MOVLB 0x0
0A90  00C3     MOVWF 0x43
0A91  0870     MOVF __pcstackCOMMON, W
0A92  00C2     MOVWF INT_InterruptHandler
104:           }
0A93  0008     RETURN
105:           
106:           void INT_DefaultInterruptHandler(void){
107:               // add your INT interrupt custom code
108:               // or set custom function using INT_SetInterruptHandler()
109:           }
110:           /**
111:            End of File
112:           */
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/system/src/clock.c
1:             /**
2:              * CLOCK Generated Driver Source File
3:              * 
4:              * @file clock.c
5:              * 
6:              * @ingroup clockdriver 
7:              * 
8:              * @brief This is the generated driver implementation file for the CLOCK.
9:              *
10:             * @version Driver Version 1.0.0
11:            */
12:            
13:            /*
14:            © [2023] Microchip Technology Inc. and its subsidiaries.
15:            
16:                Subject to your compliance with these terms, you may use Microchip 
17:                software and any derivatives exclusively with Microchip products. 
18:                You are responsible for complying with 3rd party license terms  
19:                applicable to your use of 3rd party software (including open source  
20:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
21:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
22:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
23:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
24:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
25:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
26:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
28:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
29:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
30:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
31:                THIS SOFTWARE.
32:            */
33:            
34:            #include <xc.h>
35:            #include "../clock.h"
36:            
37:            void CLOCK_Initialize(void)
38:            {
39:                // Set the CLOCK CONTROL module to the options selected in the user interface.
40:                // 
41:                OSCCON2 = 0x60;
0AE3  3060     MOVLW 0x60
0AE4  0144     MOVLB 0x4
0AE5  008E     MOVWF OSCCON2
42:                // SOSCPWR Low power; 
43:                OSCCON3 = 0x0;
0AE6  018F     CLRF OSCCON3
44:                // HFOEN disabled; MFOEN disabled; LFOEN disabled; SOSCEN disabled; ADOEN disabled; 
45:                OSCEN = 0x0;
0AE7  0191     CLRF OSCEN
46:                // HFFRQ 16_MHz; 
47:                OSCFRQ = 0x4;
0AE8  3004     MOVLW 0x4
0AE9  0093     MOVWF OSCFRQ
48:                // 
49:                OSCSTAT = 0x0;
0AEA  0190     CLRF OSCSTAT
50:                // TUN undefined; 
51:                OSCTUNE = 0x0;
0AEB  0192     CLRF OSCTUNE
52:                // ACTEN disabled; ACTUD enabled; ACTLOCK Not locked; ACTORS In range; 
53:                ACTCON = 0x0;
0AEC  0194     CLRF ACTCON
54:            }
0AED  0008     RETURN
55:            /**
56:             End of File
57:            */
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/mcc_generated_files/clc/src/clc4.c
1:             /**
2:              * CLC4 Generated Driver File
3:              * 
4:              * @file clc4.c
5:              * 
6:              * @ingroup  clc4
7:              * 
8:              * @brief This is the generated driver implementation file for the CLC4 driver.
9:              *
10:             * @version CLC4 Driver Version 1.0.1
11:            */
12:            /*
13:            © [2023] Microchip Technology Inc. and its subsidiaries.
14:            
15:                Subject to your compliance with these terms, you may use Microchip 
16:                software and any derivatives exclusively with Microchip products. 
17:                You are responsible for complying with 3rd party license terms  
18:                applicable to your use of 3rd party software (including open source  
19:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
20:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
21:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
22:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
23:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
24:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
25:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
26:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
27:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
28:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
29:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
30:                THIS SOFTWARE.
31:            */
32:            
33:            
34:            #include <xc.h>
35:            #include "../clc4.h"
36:            
37:            static void (*CLC4_CLCI_InterruptHandler)(void);
38:            static void CLC4_DefaultCLCI_ISR(void);
39:            
40:            void CLC4_Initialize(void)
41:            {
42:                
43:                // SLCT 0x3; 
44:                CLCSELECT = 0x3;
0DB6  3003     MOVLW 0x3
0DB7  014B     MOVLB 0xB
0DB8  0096     MOVWF CLCSELECT
45:                // LCG1POL not_inverted; LCG2POL inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
46:                CLCnPOL = 0xA;
0DB9  300A     MOVLW 0xA
0DBA  008D     MOVWF CLCnPOL
47:                // LCD1S TMR2; 
48:                CLCnSEL0 = 0xF;
0DBB  300F     MOVLW 0xF
0DBC  008E     MOVWF CLCnSEL0
49:                // LCD2S CLCIN0 (CLCIN0PPS); 
50:                CLCnSEL1 = 0x0;
0DBD  018F     CLRF CLCnSEL1
51:                // LCD3S CLCIN0 (CLCIN0PPS); 
52:                CLCnSEL2 = 0x0;
0DBE  0190     CLRF CLCnSEL2
53:                // LCD4S CLCIN0 (CLCIN0PPS); 
54:                CLCnSEL3 = 0x0;
0DBF  0191     CLRF CLCnSEL3
55:                // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
56:                CLCnGLS0 = 0x2;
0DC0  3002     MOVLW 0x2
0DC1  0092     MOVWF CLCnGLS0
57:                // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T disabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
58:                CLCnGLS1 = 0x0;
0DC2  0193     CLRF CLCnGLS1
59:                // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T disabled; LCG3D4N disabled; LCG3D4T disabled; 
60:                CLCnGLS2 = 0x0;
0DC3  0194     CLRF CLCnGLS2
61:                // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
62:                CLCnGLS3 = 0x0;
0DC4  0195     CLRF CLCnGLS3
63:                // LCOUT 0x00; 
64:                CLCDATA = 0x0;
0DC5  0197     CLRF CLCDATA
65:                // LCMODE JK flip-flop with R; LCINTN enabled; LCINTP enabled; LCEN enabled; 
66:                CLCnCON = 0x9E;
0DC6  309E     MOVLW 0x9E
0DC7  008C     MOVWF CLCnCON
67:            
68:                // Clear the CLC interrupt flag
69:                PIR3bits.CLC4IF = 0;
0DC8  0141     MOVLB 0x1
0DC9  108F     BCF PIR3, 0x1
70:                //Configure interrupt handlers
71:                CLC4_CLCI_SetInterruptHandler(CLC4_DefaultCLCI_ISR);
0DCA  3000     MOVLW 0x0
0DCB  00F0     MOVWF 0xF0
0DCC  3000     MOVLW 0x0
0DCD  00F1     MOVWF 0xF1
0DCE  318A     MOVLP 0xA
0DCF  2288     CALL 0x288
0DD0  318D     MOVLP 0xD
72:                // Enabling CLC4 interrupt.
73:                PIE3bits.CLC4IE = 1;
0DD1  0141     MOVLB 0x1
0DD2  1499     BSF PIE3, 0x1
74:            }
0DD3  0008     RETURN
75:            
76:            void CLC4_ISR(void)
77:            {   
78:                // Clear the CLC interrupt flag
79:                PIR3bits.CLC4IF = 0;
0A64  0141     MOVLB 0x1
0A65  108F     BCF PIR3, 0x1
80:                sw0_flag = 1;
0A66  0140     MOVLB 0x0
0A67  01C5     CLRF sw0_flag
0A68  0AC5     INCF sw0_flag, F
81:            //    if (CLC4_CLCI_InterruptHandler != NULL)
82:            //    {
83:            //        CLC4_CLCI_InterruptHandler();
84:            //    }
85:            }
0A69  0008     RETURN
86:            
87:            
88:            void CLC4_CLCI_SetInterruptHandler(void (* InterruptHandler)(void))
89:            {
90:                CLC4_CLCI_InterruptHandler = InterruptHandler;
0A88  0871     MOVF str, W
0A89  0140     MOVLB 0x0
0A8A  00E0     MOVWF 0x60
0A8B  0870     MOVF __pcstackCOMMON, W
0A8C  00DF     MOVWF CLC4_CLCI_InterruptHandler
91:            }
0A8D  0008     RETURN
92:            
93:            static void CLC4_DefaultCLCI_ISR(void)
94:            {
95:                //Add your interrupt code here or
96:                //Use CLC4_CLCI_SetInterruptHandler() function to use Custom ISR
97:            }
98:            
99:            bool CLC4_OutputStatusGet(void)
100:           {
101:               return(CLCDATAbits.CLC4OUT);
102:           }
103:           /**
104:            End of File
105:           */
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/main.c
1:              /*
2:              * MAIN Generated Driver File
3:              * 
4:              * @file main.c
5:              * 
6:              * @defgroup main MAIN
7:              * 
8:              * @brief This is the generated driver implementation file for the MAIN driver.
9:              *
10:             * @version MAIN Driver Version 1.0.0
11:            */
12:            
13:            /*
14:            © [2022] Microchip Technology Inc. and its subsidiaries.
15:            
16:                Subject to your compliance with these terms, you may use Microchip 
17:                software and any derivatives exclusively with Microchip products. 
18:                You are responsible for complying with 3rd party license terms  
19:                applicable to your use of 3rd party software (including open source  
20:                software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
21:                NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
22:                SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
23:                MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
24:                WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
25:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
26:                KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
27:                MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
28:                FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
29:                TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
30:                EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
31:                THIS SOFTWARE.
32:            */
33:            #include "mcc_generated_files/system/system.h"
34:            #include "Basic_Init.h"
35:            #include "CCP.h"
36:            #include "CLC_NCO.h"
37:            #include "IOC_w_Timer.h"
38:            #include "IOC_wo_Timer.h"
39:            #include "Polled_Input.h"
40:            #include "Pulse_Generator.h"
41:            #include "Timer1_Gate.h"
42:            
43:            /*
44:                Main application
45:            */
46:            
47:            enum state {                                                            // Setup all states (measuring method) for project
48:                PULSE_GENERATOR,
49:                TIMER1,
50:                CLC_NCO1,
51:                CLC_NCO2,
52:                CLC_NCO3,
53:                CCP,
54:                IOC_W_TIMER,
55:                IOC_WO_TIMER,
56:                POLLED_INPUT,
57:            };
58:            
59:            int main(void)
60:            {
61:                SYSTEM_Initialize();
0032  318C     MOVLP 0xC
0033  2411     CALL 0x411
0034  3180     MOVLP 0x0
62:            
63:                INTERRUPT_GlobalInterruptEnable();                                  // Enable the Global Interrupts 
0035  178B     BSF INTCON, 0x7
64:            
65:                INTERRUPT_PeripheralInterruptEnable();                              // Enable the Peripheral Interrupts 
0036  170B     BSF INTCON, 0x6
66:            
67:                enum state currentState = PULSE_GENERATOR;                          // Set initial state as Pulse Generator
0037  0140     MOVLB 0x0
0038  01DD     CLRF currentState
68:                uint8_t InitFlag = 0;
0039  01DE     CLRF InitFlag
003A  2973     GOTO 0x173
69:            
70:                while(1){
71:                    switch (currentState) {                                         // Check the current state, and go to that specific case
72:                        case PULSE_GENERATOR:                                       // Pulse Generator Case
73:                            if (InitFlag == 0) {                                    // Check if InitFlag is 0
003B  085E     MOVF InitFlag, W
003C  1D03     BTFSS STATUS, 0x2
003D  283F     GOTO 0x3F
003E  2840     GOTO 0x40
003F  284B     GOTO 0x4B
74:                                EUSART1_sendString("\nWelcome to Pulse Generator"); // Send a message over UART
0040  304E     MOVLW 0x4E
0041  00F1     MOVWF str
0042  3090     MOVLW 0x90
0043  00F2     MOVWF number
0044  318E     MOVLP 0xE
0045  26B3     CALL 0x6B3
0046  3180     MOVLP 0x0
75:                                InitFlag = 1;                                       // Set InitFlag to 1
0047  0140     MOVLB 0x0
0048  01DE     CLRF InitFlag
0049  0ADE     INCF InitFlag, F
76:                            }            
004A  2854     GOTO 0x54
77:                            else if (sw0_flag == 1) {                               // Check is sw0_flag is 1 (triggered by the CLC4 Interrupt Flag CLC4IF)
004B  0345     DECF sw0_flag, W
004C  1D03     BTFSS STATUS, 0x2
004D  284F     GOTO 0x4F
004E  2850     GOTO 0x50
004F  2854     GOTO 0x54
78:                                sw0_flag = 0;                                       // Clear the sw0_flag
0050  01C5     CLRF sw0_flag
79:                                InitFlag = 0;                                       // Clear the InitFlag
0051  01DE     CLRF InitFlag
80:                                currentState = TIMER1;                              // Change the state to TIMER1
0052  01DD     CLRF currentState
0053  0ADD     INCF currentState, F
81:                            }
82:                            Pulse_Generator();                                      // Run the Pulse_Generator function
0054  3182     MOVLP 0x2
0055  22A7     CALL 0x2A7
0056  3180     MOVLP 0x0
83:                            break;                                                  // break out of the structure (goes to top of while loop)
0057  2973     GOTO 0x173
84:            
85:                        case TIMER1:                                                // Timer1 Gate Method
86:                            if (InitFlag == 0) {                                    
0058  085E     MOVF InitFlag, W
0059  1D03     BTFSS STATUS, 0x2
005A  285C     GOTO 0x5C
005B  285D     GOTO 0x5D
005C  286E     GOTO 0x6E
87:                                Pins_PPS_Reset();                                   // Reset all Pins and PPS in preparation for a new initialization
005D  318B     MOVLP 0xB
005E  2380     CALL 0x380
005F  3180     MOVLP 0x0
88:                                EUSART1_sendString("\nWelcome to Timer1 Gate");     // Send a message over UART
0060  30EC     MOVLW 0xEC
0061  00F1     MOVWF str
0062  3090     MOVLW 0x90
0063  00F2     MOVWF number
0064  318E     MOVLP 0xE
0065  26B3     CALL 0x6B3
0066  3180     MOVLP 0x0
89:                                Timer1_Gate_Initialize();                           // Run the Timer1 Gate Initialization function
0067  318A     MOVLP 0xA
0068  22A7     CALL 0x2A7
0069  3180     MOVLP 0x0
90:                                InitFlag = 1;
006A  0140     MOVLB 0x0
006B  01DE     CLRF InitFlag
006C  0ADE     INCF InitFlag, F
91:                            }            
006D  2879     GOTO 0x79
92:                            else if (sw0_flag == 1) {
006E  0345     DECF sw0_flag, W
006F  1D03     BTFSS STATUS, 0x2
0070  2872     GOTO 0x72
0071  2873     GOTO 0x73
0072  2879     GOTO 0x79
93:                                sw0_flag = 0;
0073  01C5     CLRF sw0_flag
94:                                InitFlag = 0;
0074  01DE     CLRF InitFlag
95:                                currentState = CLC_NCO1;                            // Change the state to CLC_NCO1
0075  3002     MOVLW 0x2
0076  00DB     MOVWF 0x5B
0077  085B     MOVF 0x5B, W
0078  00DD     MOVWF currentState
96:                            }
97:                            Timer1_Gate_Calculations();                             // Run the Timer1 Gate Calculation function (will output data over UART)
0079  3183     MOVLP 0x3
007A  23A8     CALL 0x3A8
007B  3180     MOVLP 0x0
98:                            break;
007C  2973     GOTO 0x173
99:                            
100:                       case CLC_NCO1:                                              // First CLC-NCO Method
101:                           if (InitFlag == 0) {
007D  085E     MOVF InitFlag, W
007E  1D03     BTFSS STATUS, 0x2
007F  2881     GOTO 0x81
0080  2882     GOTO 0x82
0081  2893     GOTO 0x93
102:                               Pins_PPS_Reset();                                   
0082  318B     MOVLP 0xB
0083  2380     CALL 0x380
0084  3180     MOVLP 0x0
103:                               EUSART1_sendString("\nWelcome to CLC and NCO 1");   // Send a message over UART
0085  3085     MOVLW 0x85
0086  00F1     MOVWF str
0087  3090     MOVLW 0x90
0088  00F2     MOVWF number
0089  318E     MOVLP 0xE
008A  26B3     CALL 0x6B3
008B  3180     MOVLP 0x0
104:                               CLC_NCO1_Initialize();                              // Run the first CLC NCO Initialization function
008C  318C     MOVLP 0xC
008D  2439     CALL 0x439
008E  3180     MOVLP 0x0
105:                               InitFlag = 1;
008F  0140     MOVLB 0x0
0090  01DE     CLRF InitFlag
0091  0ADE     INCF InitFlag, F
106:                           }            
0092  289E     GOTO 0x9E
107:                           else if (sw0_flag == 1) {
0093  0345     DECF sw0_flag, W
0094  1D03     BTFSS STATUS, 0x2
0095  2897     GOTO 0x97
0096  2898     GOTO 0x98
0097  289E     GOTO 0x9E
108:                               sw0_flag = 0;
0098  01C5     CLRF sw0_flag
109:                               InitFlag = 0;
0099  01DE     CLRF InitFlag
110:                               currentState = CLC_NCO2;                            // Change the state to CLC_NCO2
009A  3003     MOVLW 0x3
009B  00DB     MOVWF 0x5B
009C  085B     MOVF 0x5B, W
009D  00DD     MOVWF currentState
111:                           }
112:                           CLC_NCO1_Calculations();                                // Run the first CLC NCO Calculation function (will output data over UART)
009E  318F     MOVLP 0xF
009F  273A     CALL 0x73A
00A0  3180     MOVLP 0x0
113:                           break;
00A1  2973     GOTO 0x173
114:                           
115:                      case CLC_NCO2:                                               // Second CLC-NCO Method
116:                           if (InitFlag == 0) {
00A2  085E     MOVF InitFlag, W
00A3  1D03     BTFSS STATUS, 0x2
00A4  28A6     GOTO 0xA6
00A5  28A7     GOTO 0xA7
00A6  28B8     GOTO 0xB8
117:                               Pins_PPS_Reset();                                   
00A7  318B     MOVLP 0xB
00A8  2380     CALL 0x380
00A9  3180     MOVLP 0x0
118:                               EUSART1_sendString("\nWelcome to CLC and NCO 2");   // Send a message over UART
00AA  309F     MOVLW 0x9F
00AB  00F1     MOVWF str
00AC  3090     MOVLW 0x90
00AD  00F2     MOVWF number
00AE  318E     MOVLP 0xE
00AF  26B3     CALL 0x6B3
00B0  3180     MOVLP 0x0
119:                               CLC_NCO2_Initialize();                              // Run the second CLC NCO Initialization function
00B1  318C     MOVLP 0xC
00B2  248E     CALL 0x48E
00B3  3180     MOVLP 0x0
120:                               InitFlag = 1;
00B4  0140     MOVLB 0x0
00B5  01DE     CLRF InitFlag
00B6  0ADE     INCF InitFlag, F
121:                           }            
00B7  28C3     GOTO 0xC3
122:                           else if (sw0_flag == 1) {
00B8  0345     DECF sw0_flag, W
00B9  1D03     BTFSS STATUS, 0x2
00BA  28BC     GOTO 0xBC
00BB  28BD     GOTO 0xBD
00BC  28C3     GOTO 0xC3
123:                               sw0_flag = 0;
00BD  01C5     CLRF sw0_flag
124:                               InitFlag = 0;
00BE  01DE     CLRF InitFlag
125:                               currentState = CLC_NCO3;                            // Change the state to CLC_NCO3
00BF  3004     MOVLW 0x4
00C0  00DB     MOVWF 0x5B
00C1  085B     MOVF 0x5B, W
00C2  00DD     MOVWF currentState
126:                           }
127:                           CLC_NCO2_Calculations();                                // Run the second CLC NCO Calculation function (will output data over UART)
00C3  3187     MOVLP 0x7
00C4  27B7     CALL 0x7B7
00C5  3180     MOVLP 0x0
128:                           break;
00C6  2973     GOTO 0x173
129:           
130:                       case CLC_NCO3:                                              // Third CLC-NCO Method
131:                           if (InitFlag == 0) {
00C7  085E     MOVF InitFlag, W
00C8  1D03     BTFSS STATUS, 0x2
00C9  28CB     GOTO 0xCB
00CA  28CC     GOTO 0xCC
00CB  28DD     GOTO 0xDD
132:                               Pins_PPS_Reset();
00CC  318B     MOVLP 0xB
00CD  2380     CALL 0x380
00CE  3180     MOVLP 0x0
133:                               EUSART1_sendString("\nWelcome to CLC and NCO 3");   // Send a message over UART
00CF  30B9     MOVLW 0xB9
00D0  00F1     MOVWF str
00D1  3090     MOVLW 0x90
00D2  00F2     MOVWF number
00D3  318E     MOVLP 0xE
00D4  26B3     CALL 0x6B3
00D5  3180     MOVLP 0x0
134:                               CLC_NCO3_Initialize();                              // Run the third CLC NCO Initialization function
00D6  318D     MOVLP 0xD
00D7  250E     CALL 0x50E
00D8  3180     MOVLP 0x0
135:                               InitFlag = 1;
00D9  0140     MOVLB 0x0
00DA  01DE     CLRF InitFlag
00DB  0ADE     INCF InitFlag, F
136:                           }            
00DC  28E8     GOTO 0xE8
137:                           else if (sw0_flag == 1) {
00DD  0345     DECF sw0_flag, W
00DE  1D03     BTFSS STATUS, 0x2
00DF  28E1     GOTO 0xE1
00E0  28E2     GOTO 0xE2
00E1  28E8     GOTO 0xE8
138:                               sw0_flag = 0;
00E2  01C5     CLRF sw0_flag
139:                               InitFlag = 0;
00E3  01DE     CLRF InitFlag
140:                               currentState = CCP;                                 // Change the state to CCP
00E4  3005     MOVLW 0x5
00E5  00DB     MOVWF 0x5B
00E6  085B     MOVF 0x5B, W
00E7  00DD     MOVWF currentState
141:                           }
142:                           CLC_NCO3_Calculations();                                // Run the third CLC NCO Calculation function (will output data over UART)
00E8  318F     MOVLP 0xF
00E9  2776     CALL 0x776
00EA  3180     MOVLP 0x0
143:                           break;
00EB  2973     GOTO 0x173
144:                           
145:                       case CCP:                                                   // CCP Method
146:                           if (InitFlag == 0) {
00EC  085E     MOVF InitFlag, W
00ED  1D03     BTFSS STATUS, 0x2
00EE  28F0     GOTO 0xF0
00EF  28F1     GOTO 0xF1
00F0  2902     GOTO 0x102
147:                               Pins_PPS_Reset();
00F1  318B     MOVLP 0xB
00F2  2380     CALL 0x380
00F3  3180     MOVLP 0x0
148:                               EUSART1_sendString("\nWelcome to CCP");             // Send a message over UART
00F4  3004     MOVLW 0x4
00F5  00F1     MOVWF str
00F6  3091     MOVLW 0x91
00F7  00F2     MOVWF number
00F8  318E     MOVLP 0xE
00F9  26B3     CALL 0x6B3
00FA  3180     MOVLP 0x0
149:                               CCP_Initialize();                                   // Run the CCP Initialization function
00FB  318B     MOVLP 0xB
00FC  23C5     CALL 0x3C5
00FD  3180     MOVLP 0x0
150:                               InitFlag = 1;
00FE  0140     MOVLB 0x0
00FF  01DE     CLRF InitFlag
0100  0ADE     INCF InitFlag, F
151:                           }            
0101  290D     GOTO 0x10D
152:                           else if (sw0_flag == 1) {
0102  0345     DECF sw0_flag, W
0103  1D03     BTFSS STATUS, 0x2
0104  2906     GOTO 0x106
0105  2907     GOTO 0x107
0106  290D     GOTO 0x10D
153:                               sw0_flag = 0;
0107  01C5     CLRF sw0_flag
154:                               InitFlag = 0;
0108  01DE     CLRF InitFlag
155:                               currentState = IOC_W_TIMER;                         // Change the state to IOC_W_TIMER
0109  3006     MOVLW 0x6
010A  00DB     MOVWF 0x5B
010B  085B     MOVF 0x5B, W
010C  00DD     MOVWF currentState
156:                           }
157:                           CCP_Calculations();                                     // Run the CCP Calculation function (will output data over UART)
010D  3181     MOVLP 0x1
010E  219B     CALL 0x19B
010F  3180     MOVLP 0x0
158:                           break;
0110  2973     GOTO 0x173
159:                           
160:                      case IOC_W_TIMER:                                            // IOC with Timer Method
161:                           if (InitFlag == 0) {
0111  085E     MOVF InitFlag, W
0112  1D03     BTFSS STATUS, 0x2
0113  2915     GOTO 0x115
0114  2916     GOTO 0x116
0115  2924     GOTO 0x124
162:                               Pins_PPS_Reset();
0116  318B     MOVLP 0xB
0117  2380     CALL 0x380
0118  3180     MOVLP 0x0
163:                               EUSART1_sendString("\nWelcome to IOC with Timer");  // Send a message over UART
0119  306A     MOVLW 0x6A
011A  00F1     MOVWF str
011B  3090     MOVLW 0x90
011C  00F2     MOVWF number
011D  318E     MOVLP 0xE
011E  26B3     CALL 0x6B3
011F  3180     MOVLP 0x0
164:                               InitFlag = 1;
0120  0140     MOVLB 0x0
0121  01DE     CLRF InitFlag
0122  0ADE     INCF InitFlag, F
165:                           }            
0123  292F     GOTO 0x12F
166:                           else if (sw0_flag == 1) {
0124  0345     DECF sw0_flag, W
0125  1D03     BTFSS STATUS, 0x2
0126  2928     GOTO 0x128
0127  2929     GOTO 0x129
0128  292F     GOTO 0x12F
167:                               sw0_flag = 0;
0129  01C5     CLRF sw0_flag
168:                               InitFlag = 0;
012A  01DE     CLRF InitFlag
169:                               currentState = IOC_WO_TIMER;                        // CHange the state to IOC_WO_TIMER
012B  3007     MOVLW 0x7
012C  00DB     MOVWF 0x5B
012D  085B     MOVF 0x5B, W
012E  00DD     MOVWF currentState
170:                           }
171:                           IOC_w_Timer_Calculations();                             // Run the IOC with Timer Calculation function (will output data over UART)
012F  3184     MOVLP 0x4
0130  2473     CALL 0x473
0131  3180     MOVLP 0x0
172:                           break;
0132  2973     GOTO 0x173
173:           
174:                       case IOC_WO_TIMER:                                          // IOC without Timer Method
175:                           if (InitFlag == 0) {
0133  085E     MOVF InitFlag, W
0134  1D03     BTFSS STATUS, 0x2
0135  2937     GOTO 0x137
0136  2938     GOTO 0x138
0137  2946     GOTO 0x146
176:                               Pins_PPS_Reset();
0138  318B     MOVLP 0xB
0139  2380     CALL 0x380
013A  3180     MOVLP 0x0
177:                               EUSART1_sendString("\nWelcome to IOC without Timer");   // Send a message over UART
013B  3030     MOVLW 0x30
013C  00F1     MOVWF str
013D  3090     MOVLW 0x90
013E  00F2     MOVWF number
013F  318E     MOVLP 0xE
0140  26B3     CALL 0x6B3
0141  3180     MOVLP 0x0
178:                               InitFlag = 1;
0142  0140     MOVLB 0x0
0143  01DE     CLRF InitFlag
0144  0ADE     INCF InitFlag, F
179:                           }            
0145  2951     GOTO 0x151
180:                           else if (sw0_flag == 1) {
0146  0345     DECF sw0_flag, W
0147  1D03     BTFSS STATUS, 0x2
0148  294A     GOTO 0x14A
0149  294B     GOTO 0x14B
014A  2951     GOTO 0x151
181:                               sw0_flag = 0;
014B  01C5     CLRF sw0_flag
182:                               InitFlag = 0;
014C  01DE     CLRF InitFlag
183:                               currentState = POLLED_INPUT;                        // Change the state to POLLED_INPUT
014D  3008     MOVLW 0x8
014E  00DB     MOVWF 0x5B
014F  085B     MOVF 0x5B, W
0150  00DD     MOVWF currentState
184:                           }
185:                           IOC_wo_Timer_Calculations();                            // Run the IOC without Timer Calculation function (will output data over UART)
0151  3185     MOVLP 0x5
0152  2538     CALL 0x538
0153  3180     MOVLP 0x0
186:                           break;
0154  2973     GOTO 0x173
187:                           
188:                       case POLLED_INPUT:                                          // Polled Input Method
189:                           if (InitFlag == 0) {
0155  085E     MOVF InitFlag, W
0156  1D03     BTFSS STATUS, 0x2
0157  2959     GOTO 0x159
0158  295A     GOTO 0x15A
0159  2968     GOTO 0x168
190:                               Pins_PPS_Reset();
015A  318B     MOVLP 0xB
015B  2380     CALL 0x380
015C  3180     MOVLP 0x0
191:                               EUSART1_sendString("\nWelcome to Polled Input");    // Send a message over UART
015D  30D3     MOVLW 0xD3
015E  00F1     MOVWF str
015F  3090     MOVLW 0x90
0160  00F2     MOVWF number
0161  318E     MOVLP 0xE
0162  26B3     CALL 0x6B3
0163  3180     MOVLP 0x0
192:                               InitFlag = 1;
0164  0140     MOVLB 0x0
0165  01DE     CLRF InitFlag
0166  0ADE     INCF InitFlag, F
193:                           }            
0167  2970     GOTO 0x170
194:                           else if (sw0_flag == 1) {
0168  0345     DECF sw0_flag, W
0169  1D03     BTFSS STATUS, 0x2
016A  296C     GOTO 0x16C
016B  296D     GOTO 0x16D
016C  2970     GOTO 0x170
195:                               sw0_flag = 0;
016D  01C5     CLRF sw0_flag
196:                               InitFlag = 0;
016E  01DE     CLRF InitFlag
197:                               currentState = PULSE_GENERATOR;                     // Change the state to PULSE_GENERATOR
016F  01DD     CLRF currentState
198:                           }
199:                           Polled_Input_Calculations();                            // Run the Polled Input Calculation function (will output data over UART)
0170  3185     MOVLP 0x5
0171  25FA     CALL 0x5FA
0172  3180     MOVLP 0x0
200:                           break;
201:                   }
0173  0140     MOVLB 0x0
0174  085D     MOVF currentState, W
0175  00DB     MOVWF 0x5B
0176  01DC     CLRF 0x5C
0177  085C     MOVF 0x5C, W
0178  3A00     XORLW 0x0
0179  1903     BTFSC STATUS, 0x2
017A  297C     GOTO 0x17C
017B  2973     GOTO 0x173
017C  085B     MOVF 0x5B, W
017D  3A00     XORLW 0x0
017E  1903     BTFSC STATUS, 0x2
017F  283B     GOTO 0x3B
0180  3A01     XORLW 0x1
0181  1903     BTFSC STATUS, 0x2
0182  2858     GOTO 0x58
0183  3A03     XORLW 0x3
0184  1903     BTFSC STATUS, 0x2
0185  287D     GOTO 0x7D
0186  3A01     XORLW 0x1
0187  1903     BTFSC STATUS, 0x2
0188  28A2     GOTO 0xA2
0189  3A07     XORLW 0x7
018A  1903     BTFSC STATUS, 0x2
018B  28C7     GOTO 0xC7
018C  3A01     XORLW 0x1
018D  1903     BTFSC STATUS, 0x2
018E  28EC     GOTO 0xEC
018F  3A03     XORLW 0x3
0190  1903     BTFSC STATUS, 0x2
0191  2911     GOTO 0x111
0192  3A01     XORLW 0x1
0193  1903     BTFSC STATUS, 0x2
0194  2933     GOTO 0x133
0195  3A0F     XORLW 0xF
0196  1903     BTFSC STATUS, 0x2
0197  2955     GOTO 0x155
0198  2973     GOTO 0x173
0199  3180     MOVLP 0x0
202:               }    
203:           }
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/Timer1_Gate.c
1:             /*
2:              * File:   Timer1_Gate.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:31 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "Timer1_Gate.h"
11:            #include "Basic_Init.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:            void Timer1_Gate_Calculations(void){
15:                // TIMER1 GATE DUTY CYCLE MEASUREMENT //
16:                    TMR1GIF = 0;                            // Clear Gate Flag
03A8  0141     MOVLB 0x1
03A9  120D     BCF PIR1, 0x4
17:                    TMR1IF = 0;                             // Clear Timer1 Flag
03AA  118D     BCF PIR1, 0x3
18:                    T1GCONbits.GE = 1;                      // Enable Timer1 Gate
03AB  0145     MOVLB 0x5
03AC  178F     BSF T1GCON, 0x7
19:                    T1GCONbits.GPOL = 1;                    // Enable Timer1 Gate Polarity
03AD  170F     BSF T1GCON, 0x6
20:                    T1GCONbits.GTM = 1;                     // Enable Timer1 Gate Toggle Mode
03AE  168F     BSF T1GCON, 0x5
21:                    TMR1H = TMR1L = 0;                      // Clear TMR1H and TMR1L
03AF  018C     CLRF TMR1
03B0  018D     CLRF TMR1H
22:                    // Uncomment line below if pulses are longer than 4.1ms
23:                    //uint8_t overflow_count = 0;             // Clear the overflow_count 
24:                    
25:                    Timer1_StartSinglePulseAcquisition();   // Enable T1GGO bit, start measuring the pulse
03B1  318A     MOVLP 0xA
03B2  2246     CALL 0x246
03B3  3183     MOVLP 0x3
26:                    while(!TMR1GIF){                        // Wait until the Gate Flag is set
27:                    // Uncomment 3 lines below if pulse are longer than 4.1ms
28:                        //if (TMR1IF == 1){                   // Check if Timer1 Flag has been set
29:                        //    overflow_count++;               // If flag is set, increment overflow_count
30:                        //}
31:                    } 
03B4  0141     MOVLB 0x1
03B5  1E0D     BTFSS PIR1, 0x4
03B6  2BB8     GOTO 0x3B8
03B7  2BB9     GOTO 0x3B9
03B8  2BB4     GOTO 0x3B4
32:                    uint8_t period_low = TMR1L;             // Save period low byte data
03B9  0145     MOVLB 0x5
03BA  080C     MOVF TMR1, W
03BB  0140     MOVLB 0x0
03BC  00C6     MOVWF __pcstackBANK0
03BD  0846     MOVF __pcstackBANK0, W
03BE  00D6     MOVWF period_low
33:                    uint16_t period_high = TMR1H;            // Save period high byte data
03BF  0145     MOVLB 0x5
03C0  080D     MOVF TMR1H, W
03C1  0140     MOVLB 0x0
03C2  00C6     MOVWF __pcstackBANK0
03C3  01C7     CLRF 0x47
03C4  0846     MOVF __pcstackBANK0, W
03C5  00D2     MOVWF period_count
03C6  0847     MOVF 0x47, W
03C7  00D3     MOVWF 0x53
34:                    
35:                // TIMER1 GATE PULSE MEASUREMENT //    
36:                    TMR1GIF = 0;                            
03C8  0141     MOVLB 0x1
03C9  120D     BCF PIR1, 0x4
37:                    TMR1IF = 0;
03CA  118D     BCF PIR1, 0x3
38:                    T1GCONbits.GPOL = 0;                    // Clear Timer1 Gate Polarity 
03CB  0145     MOVLB 0x5
03CC  130F     BCF T1GCON, 0x6
39:                    T1GCONbits.GTM = 0;                     // Clear Timer1 Gate Toggle Mode
03CD  128F     BCF T1GCON, 0x5
40:                    TMR1H = TMR1L = 0;
03CE  018C     CLRF TMR1
03CF  018D     CLRF TMR1H
41:                    // Uncomment line below if pulses are longer than 4.1ms
42:                    //overflow_count = 0;                     
43:                    Timer1_StartSinglePulseAcquisition();   
03D0  318A     MOVLP 0xA
03D1  2246     CALL 0x246
03D2  3183     MOVLP 0x3
44:                    while(!TMR1GIF){                        
45:                    // Uncomment 3 lines below if pulse are longer than 4.1ms
46:                        //if (TMR1IF == 1){                   
47:                        //    overflow_count++;               
48:                        //}
49:                    }       
03D3  0141     MOVLB 0x1
03D4  1E0D     BTFSS PIR1, 0x4
03D5  2BD7     GOTO 0x3D7
03D6  2BD8     GOTO 0x3D8
03D7  2BD3     GOTO 0x3D3
50:                    
51:                    uint8_t pulse_width_low = TMR1L;        // Save pulse width low byte data
03D8  0145     MOVLB 0x5
03D9  080C     MOVF TMR1, W
03DA  0140     MOVLB 0x0
03DB  00C6     MOVWF __pcstackBANK0
03DC  0846     MOVF __pcstackBANK0, W
03DD  00D7     MOVWF pulse_width_low
52:                    uint16_t pulse_width_high = TMR1H;       // Save pulse width high byte data
03DE  0145     MOVLB 0x5
03DF  080D     MOVF TMR1H, W
03E0  0140     MOVLB 0x0
03E1  00C6     MOVWF __pcstackBANK0
03E2  01C7     CLRF 0x47
03E3  0846     MOVF __pcstackBANK0, W
03E4  00D4     MOVWF pulse_width_high
03E5  0847     MOVF 0x47, W
03E6  00D5     MOVWF 0x55
53:                    
54:                    // Calculate the duty cycle and output as an 8-bit value, 0-255 = 0-100%, e.g. 127 = 50%
55:                    uint24_t full_period = 0;
56:                    uint24_t full_pulse_width = 0;
03E7  3000     MOVLW 0x0
03E8  00CF     MOVWF pulse_count
03E9  3000     MOVLW 0x0
03EA  00D0     MOVWF 0x50
03EB  3000     MOVLW 0x0
03EC  00D1     MOVWF 0x51
57:                    uint24_t duty_cycle = 0;
03ED  3000     MOVLW 0x0
03EE  00D8     MOVWF duty_cycle
03EF  3000     MOVLW 0x0
03F0  00D9     MOVWF 0x59
03F1  3000     MOVLW 0x0
03F2  00DA     MOVWF 0x5A
58:                
59:                    full_period = ((period_high << 8) + period_low);
03F3  0856     MOVF period_low, W
03F4  00C6     MOVWF __pcstackBANK0
03F5  01C7     CLRF 0x47
03F6  0852     MOVF period_count, W
03F7  00C9     MOVWF TMR0_val
03F8  01C8     CLRF start
03F9  0846     MOVF __pcstackBANK0, W
03FA  0748     ADDWF start, W
03FB  00CA     MOVWF period_countH
03FC  0847     MOVF 0x47, W
03FD  3D49     ADDWFC TMR0_val, W
03FE  00CB     MOVWF period_countL
03FF  084A     MOVF period_countH, W
0400  00CC     MOVWF pulse_countH
0401  084B     MOVF period_countL, W
0402  00CD     MOVWF pulse_countL
0403  01CE     CLRF duty_cycle
60:                    full_pulse_width = ((pulse_width_high << 8) + pulse_width_low);
0404  0857     MOVF pulse_width_low, W
0405  00C6     MOVWF __pcstackBANK0
0406  01C7     CLRF 0x47
0407  0854     MOVF pulse_width_high, W
0408  00C9     MOVWF TMR0_val
0409  01C8     CLRF start
040A  0846     MOVF __pcstackBANK0, W
040B  0748     ADDWF start, W
040C  00CA     MOVWF period_countH
040D  0847     MOVF 0x47, W
040E  3D49     ADDWFC TMR0_val, W
040F  00CB     MOVWF period_countL
0410  084A     MOVF period_countH, W
0411  00CF     MOVWF pulse_count
0412  084B     MOVF period_countL, W
0413  00D0     MOVWF 0x50
0414  01D1     CLRF 0x51
61:            
62:                    duty_cycle = (full_pulse_width << 8)/full_period;
0415  084C     MOVF pulse_countH, W
0416  00F0     MOVWF __pcstackCOMMON
0417  084D     MOVF pulse_countL, W
0418  00F1     MOVWF str
0419  084E     MOVF duty_cycle, W
041A  00F2     MOVWF number
041B  084F     MOVF pulse_count, W
041C  00C6     MOVWF __pcstackBANK0
041D  0850     MOVF 0x50, W
041E  00C7     MOVWF 0x47
041F  0851     MOVF 0x51, W
0420  00C8     MOVWF start
0421  3008     MOVLW 0x8
0422  35C6     LSLF __pcstackBANK0, F
0423  0DC7     RLF 0x47, F
0424  0DC8     RLF start, F
0425  0B89     DECFSZ WREG, F
0426  2C22     GOTO 0x422
0427  0846     MOVF __pcstackBANK0, W
0428  00F3     MOVWF module
0429  0847     MOVF 0x47, W
042A  00F4     MOVWF pulse_countL
042B  0848     MOVF start, W
042C  00F5     MOVWF period_countH
042D  318F     MOVLP 0xF
042E  27B4     CALL 0x7B4
042F  3183     MOVLP 0x3
0430  0870     MOVF __pcstackCOMMON, W
0431  0140     MOVLB 0x0
0432  00D8     MOVWF duty_cycle
0433  0871     MOVF str, W
0434  00D9     MOVWF 0x59
0435  0872     MOVF number, W
0436  00DA     MOVWF 0x5A
63:                    duty_cycle = 256 - duty_cycle;
0437  0858     MOVF duty_cycle, W
0438  3C00     SUBLW 0x0
0439  00D8     MOVWF duty_cycle
043A  0859     MOVF 0x59, W
043B  1C03     BTFSS STATUS, 0x0
043C  0F59     INCFSZ 0x59, W
043D  3C01     SUBLW 0x1
043E  00D9     MOVWF 0x59
043F  085A     MOVF 0x5A, W
0440  1C03     BTFSS STATUS, 0x0
0441  0F5A     INCFSZ 0x5A, W
0442  3C00     SUBLW 0x0
0443  00DA     MOVWF 0x5A
64:                    
65:                    // Send Pulse measurement over UART
66:                    EUSART1_sendString("\nPULSE:");
0444  3050     MOVLW 0x50
0445  00F1     MOVWF str
0446  3091     MOVLW 0x91
0447  00F2     MOVWF number
0448  318E     MOVLP 0xE
0449  26B3     CALL 0x6B3
044A  3183     MOVLP 0x3
67:                    EUSART1_sendInt(pulse_width_high);
044B  0140     MOVLB 0x0
044C  0854     MOVF pulse_width_high, W
044D  318B     MOVLP 0xB
044E  2390     CALL 0x390
044F  3183     MOVLP 0x3
68:                    EUSART1_sendInt(pulse_width_low);
0450  0140     MOVLB 0x0
0451  0857     MOVF pulse_width_low, W
0452  318B     MOVLP 0xB
0453  2390     CALL 0x390
0454  3183     MOVLP 0x3
69:                    // Send Period measurement over UART
70:                    EUSART1_sendString("\nPD:"); 
0455  3069     MOVLW 0x69
0456  00F1     MOVWF str
0457  3091     MOVLW 0x91
0458  00F2     MOVWF number
0459  318E     MOVLP 0xE
045A  26B3     CALL 0x6B3
045B  3183     MOVLP 0x3
71:                    EUSART1_sendInt(period_high);
045C  0140     MOVLB 0x0
045D  0852     MOVF period_count, W
045E  318B     MOVLP 0xB
045F  2390     CALL 0x390
0460  3183     MOVLP 0x3
72:                    EUSART1_sendInt(period_low);
0461  0140     MOVLB 0x0
0462  0856     MOVF period_low, W
0463  318B     MOVLP 0xB
0464  2390     CALL 0x390
0465  3183     MOVLP 0x3
73:                    // Send Duty Cycle calculation over UART
74:                    EUSART1_sendString("\nDC:");
0466  3064     MOVLW 0x64
0467  00F1     MOVWF str
0468  3091     MOVLW 0x91
0469  00F2     MOVWF number
046A  318E     MOVLP 0xE
046B  26B3     CALL 0x6B3
046C  3183     MOVLP 0x3
75:                    EUSART1_sendInt(duty_cycle);
046D  0140     MOVLB 0x0
046E  0858     MOVF duty_cycle, W
046F  318B     MOVLP 0xB
0470  2390     CALL 0x390
0471  3183     MOVLP 0x3
76:                    // Send overflow count over UART
77:                    // Uncomment 2 lines below if pulses are longer than 4.1ms
78:                    //EUSART1_sendString("\n");  
79:                    //EUSART1_sendInt(overflow_count);
80:            }
0472  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/Pulse_Generator.c
1:             /*
2:              * File:   Pulse_Generator.c
3:              * Author: C63290
4:              *
5:              * Created on January 24, 2023, 9:17 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "Pulse_Generator.h"
11:            #include "mcc_generated_files/system/system.h"
12:            
13:            void Pulse_Generator(void){
14:                TRISAbits.TRISA3 = 0;       // Set RA3 as an output pin
02A7  0140     MOVLB 0x0
02A8  1192     BCF TRISA, 0x3
15:                ANSELAbits.ANSA3 = 0;       // Set RA3 as a digital signal
02A9  017D     MOVLB 0x3D
02AA  118C     BCF ANSELA, 0x3
16:                uint8_t i = 0;              
02AB  01F1     CLRF 0x1EF1
17:                
18:                //// 10% Duty Cycle 0x1A////
19:                for (i = 0; i < 10; i++){
02AC  01F1     CLRF 0x1EF1
20:                    LATAbits.LATA3 = 1;     // Set RA3 high
02AD  0140     MOVLB 0x0
02AE  1598     BSF LATA, 0x3
21:                    __delay_us(100);        // Wait for 100us
02AF  3085     MOVLW 0x85
02B0  0B89     DECFSZ WREG, F
02B1  2AB0     GOTO 0x2B0
02B2  0000     NOP
22:                    LATAbits.LATA3 = 0;     // Set RA3 low
02B3  0140     MOVLB 0x0
02B4  1198     BCF LATA, 0x3
23:                    __delay_us(900);        // Wait for 900us
02B5  3005     MOVLW 0x5
02B6  00F0     MOVWF __pcstackCOMMON
02B7  30AC     MOVLW 0xAC
02B8  0B89     DECFSZ WREG, F
02B9  2AB8     GOTO 0x2B8
02BA  0BF0     DECFSZ __pcstackCOMMON, F
02BB  2AB8     GOTO 0x2B8
24:                }
02BC  3001     MOVLW 0x1
02BD  00F0     MOVWF __pcstackCOMMON
02BE  0870     MOVF __pcstackCOMMON, W
02BF  07F1     ADDWF str, F
02C0  300A     MOVLW 0xA
02C1  0271     SUBWF str, W
02C2  1C03     BTFSS STATUS, 0x0
02C3  2AC5     GOTO 0x2C5
02C4  2AC6     GOTO 0x2C6
02C5  2AAD     GOTO 0x2AD
25:                    
26:                //// 20% Duty Cycle 0x33////
27:                for (i = 0; i < 10; i++){
02C6  01F1     CLRF str
28:                    LATAbits.LATA3 = 1;
02C7  0140     MOVLB 0x0
02C8  1598     BSF LATA, 0x3
29:                    __delay_us(200);        // Wait for 200us
02C9  30A0     MOVLW 0xA0
02CA  3200     BRA 0x2CB
02CB  0B89     DECFSZ WREG, F
02CC  2ACA     GOTO 0x2CA
30:                    LATAbits.LATA3 = 0;
02CD  0140     MOVLB 0x0
02CE  1198     BCF LATA, 0x3
31:                    __delay_us(800);        // Wait for 800us
02CF  3005     MOVLW 0x5
02D0  00F0     MOVWF __pcstackCOMMON
02D1  3026     MOVLW 0x26
02D2  0B89     DECFSZ WREG, F
02D3  2AD2     GOTO 0x2D2
02D4  0BF0     DECFSZ __pcstackCOMMON, F
02D5  2AD2     GOTO 0x2D2
02D6  3200     BRA 0x2D7
32:                }
02D7  3001     MOVLW 0x1
02D8  00F0     MOVWF __pcstackCOMMON
02D9  0870     MOVF __pcstackCOMMON, W
02DA  07F1     ADDWF str, F
02DB  300A     MOVLW 0xA
02DC  0271     SUBWF str, W
02DD  1C03     BTFSS STATUS, 0x0
02DE  2AE0     GOTO 0x2E0
02DF  2AE1     GOTO 0x2E1
02E0  2AC7     GOTO 0x2C7
33:                    
34:                //// 30% Duty Cycle 0x4D////
35:                for (i = 0; i < 10; i++){
02E1  01F1     CLRF str
36:                    LATAbits.LATA3 = 1;
02E2  0140     MOVLB 0x0
02E3  1598     BSF LATA, 0x3
37:                    __delay_us(300);        // Wait for 300us
02E4  30F0     MOVLW 0xF0
02E5  3200     BRA 0x2E6
02E6  0B89     DECFSZ WREG, F
02E7  2AE5     GOTO 0x2E5
38:                    LATAbits.LATA3 = 0;
02E8  0140     MOVLB 0x0
02E9  1198     BCF LATA, 0x3
39:                    __delay_us(700);        // Wait for 700us
02EA  3004     MOVLW 0x4
02EB  00F0     MOVWF __pcstackCOMMON
02EC  30A2     MOVLW 0xA2
02ED  0B89     DECFSZ WREG, F
02EE  2AED     GOTO 0x2ED
02EF  0BF0     DECFSZ __pcstackCOMMON, F
02F0  2AED     GOTO 0x2ED
40:                }
02F1  3001     MOVLW 0x1
02F2  00F0     MOVWF __pcstackCOMMON
02F3  0870     MOVF __pcstackCOMMON, W
02F4  07F1     ADDWF str, F
02F5  300A     MOVLW 0xA
02F6  0271     SUBWF str, W
02F7  1C03     BTFSS STATUS, 0x0
02F8  2AFA     GOTO 0x2FA
02F9  2AFB     GOTO 0x2FB
02FA  2AE2     GOTO 0x2E2
41:                    
42:                //// 40% Duty Cycle 0x66////
43:                for (i = 0; i < 10; i++){
02FB  01F1     CLRF str
44:                    LATAbits.LATA3 = 1;
02FC  0140     MOVLB 0x0
02FD  1598     BSF LATA, 0x3
45:                    __delay_us(400);        // Wait for 400us
02FE  30E4     MOVLW 0xE4
02FF  3200     BRA 0x300
0300  3200     BRA 0x301
0301  0B89     DECFSZ WREG, F
0302  2AFF     GOTO 0x2FF
0303  3200     BRA 0x304
0304  3200     BRA 0x305
46:                    LATAbits.LATA3 = 0;
0305  0140     MOVLB 0x0
0306  1198     BCF LATA, 0x3
47:                    __delay_us(600);        // Wait for 600us
0307  3004     MOVLW 0x4
0308  00F0     MOVWF __pcstackCOMMON
0309  301C     MOVLW 0x1C
030A  0B89     DECFSZ WREG, F
030B  2B0A     GOTO 0x30A
030C  0BF0     DECFSZ __pcstackCOMMON, F
030D  2B0A     GOTO 0x30A
030E  3200     BRA 0x30F
48:                }
030F  3001     MOVLW 0x1
0310  00F0     MOVWF __pcstackCOMMON
0311  0870     MOVF __pcstackCOMMON, W
0312  07F1     ADDWF str, F
0313  300A     MOVLW 0xA
0314  0271     SUBWF str, W
0315  1C03     BTFSS STATUS, 0x0
0316  2B18     GOTO 0x318
0317  2B19     GOTO 0x319
0318  2AFC     GOTO 0x2FC
49:                    
50:                //// 50% Duty Cycle 0x80////
51:                for (i = 0; i < 10; i++){
0319  01F1     CLRF str
52:                    LATAbits.LATA3 = 1;
031A  0140     MOVLB 0x0
031B  1598     BSF LATA, 0x3
53:                    __delay_us(500);        // Wait for 500us
031C  3003     MOVLW 0x3
031D  00F0     MOVWF __pcstackCOMMON
031E  3098     MOVLW 0x98
031F  0B89     DECFSZ WREG, F
0320  2B1F     GOTO 0x31F
0321  0BF0     DECFSZ __pcstackCOMMON, F
0322  2B1F     GOTO 0x31F
54:                    LATAbits.LATA3 = 0;
0323  0140     MOVLB 0x0
0324  1198     BCF LATA, 0x3
55:                    __delay_us(500);
0325  3003     MOVLW 0x3
0326  00F0     MOVWF __pcstackCOMMON
0327  3098     MOVLW 0x98
0328  0B89     DECFSZ WREG, F
0329  2B28     GOTO 0x328
032A  0BF0     DECFSZ __pcstackCOMMON, F
032B  2B28     GOTO 0x328
56:                }
032C  3001     MOVLW 0x1
032D  00F0     MOVWF __pcstackCOMMON
032E  0870     MOVF __pcstackCOMMON, W
032F  07F1     ADDWF str, F
0330  300A     MOVLW 0xA
0331  0271     SUBWF str, W
0332  1C03     BTFSS STATUS, 0x0
0333  2B35     GOTO 0x335
0334  2B36     GOTO 0x336
0335  2B1A     GOTO 0x31A
57:                    
58:                //// 60% Duty Cycle 0x9A////
59:                for (i = 0; i < 10; i++){
0336  01F1     CLRF str
60:                    LATAbits.LATA3 = 1;
0337  0140     MOVLB 0x0
0338  1598     BSF LATA, 0x3
61:                    __delay_us(600);
0339  3004     MOVLW 0x4
033A  00F0     MOVWF __pcstackCOMMON
033B  301C     MOVLW 0x1C
033C  0B89     DECFSZ WREG, F
033D  2B3C     GOTO 0x33C
033E  0BF0     DECFSZ __pcstackCOMMON, F
033F  2B3C     GOTO 0x33C
0340  3200     BRA 0x341
62:                    LATAbits.LATA3 = 0;
0341  0140     MOVLB 0x0
0342  1198     BCF LATA, 0x3
63:                    __delay_us(400);
0343  30E4     MOVLW 0xE4
0344  3200     BRA 0x345
0345  3200     BRA 0x346
0346  0B89     DECFSZ WREG, F
0347  2B44     GOTO 0x344
0348  3200     BRA 0x349
0349  3200     BRA 0x34A
64:                }
034A  3001     MOVLW 0x1
034B  00F0     MOVWF __pcstackCOMMON
034C  0870     MOVF __pcstackCOMMON, W
034D  07F1     ADDWF str, F
034E  300A     MOVLW 0xA
034F  0271     SUBWF str, W
0350  1C03     BTFSS STATUS, 0x0
0351  2B53     GOTO 0x353
0352  2B54     GOTO 0x354
0353  2B37     GOTO 0x337
65:            
66:                //// 70% Duty Cycle 0xB3////
67:                for (i = 0; i < 10; i++){
0354  01F1     CLRF str
68:                    LATAbits.LATA3 = 1;
0355  0140     MOVLB 0x0
0356  1598     BSF LATA, 0x3
69:                    __delay_us(700);
0357  3004     MOVLW 0x4
0358  00F0     MOVWF __pcstackCOMMON
0359  30A2     MOVLW 0xA2
035A  0B89     DECFSZ WREG, F
035B  2B5A     GOTO 0x35A
035C  0BF0     DECFSZ __pcstackCOMMON, F
035D  2B5A     GOTO 0x35A
70:                    LATAbits.LATA3 = 0;
035E  0140     MOVLB 0x0
035F  1198     BCF LATA, 0x3
71:                    __delay_us(300);
0360  30F0     MOVLW 0xF0
0361  3200     BRA 0x362
0362  0B89     DECFSZ WREG, F
0363  2B61     GOTO 0x361
72:                }
0364  3001     MOVLW 0x1
0365  00F0     MOVWF __pcstackCOMMON
0366  0870     MOVF __pcstackCOMMON, W
0367  07F1     ADDWF str, F
0368  300A     MOVLW 0xA
0369  0271     SUBWF str, W
036A  1C03     BTFSS STATUS, 0x0
036B  2B6D     GOTO 0x36D
036C  2B6E     GOTO 0x36E
036D  2B55     GOTO 0x355
73:                    
74:                //// 80% Duty Cycle 0xCC////
75:                for (i = 0; i < 10; i++){
036E  01F1     CLRF str
76:                    LATAbits.LATA3 = 1;
036F  0140     MOVLB 0x0
0370  1598     BSF LATA, 0x3
77:                    __delay_us(800);
0371  3005     MOVLW 0x5
0372  00F0     MOVWF __pcstackCOMMON
0373  3026     MOVLW 0x26
0374  0B89     DECFSZ WREG, F
0375  2B74     GOTO 0x374
0376  0BF0     DECFSZ __pcstackCOMMON, F
0377  2B74     GOTO 0x374
0378  3200     BRA 0x379
78:                    LATAbits.LATA3 = 0;
0379  0140     MOVLB 0x0
037A  1198     BCF LATA, 0x3
79:                    __delay_us(200);
037B  30A0     MOVLW 0xA0
037C  3200     BRA 0x37D
037D  0B89     DECFSZ WREG, F
037E  2B7C     GOTO 0x37C
80:                }
037F  3001     MOVLW 0x1
0380  00F0     MOVWF __pcstackCOMMON
0381  0870     MOVF __pcstackCOMMON, W
0382  07F1     ADDWF str, F
0383  300A     MOVLW 0xA
0384  0271     SUBWF str, W
0385  1C03     BTFSS STATUS, 0x0
0386  2B88     GOTO 0x388
0387  2B89     GOTO 0x389
0388  2B6F     GOTO 0x36F
81:            
82:                //// 90% Duty Cycle 0xE6////
83:                for (i = 0; i < 10; i++){
0389  01F1     CLRF str
84:                    LATAbits.LATA3 = 1;
038A  0140     MOVLB 0x0
038B  1598     BSF LATA, 0x3
85:                    __delay_us(900);
038C  3005     MOVLW 0x5
038D  00F0     MOVWF __pcstackCOMMON
038E  30AC     MOVLW 0xAC
038F  0B89     DECFSZ WREG, F
0390  2B8F     GOTO 0x38F
0391  0BF0     DECFSZ __pcstackCOMMON, F
0392  2B8F     GOTO 0x38F
86:                    LATAbits.LATA3 = 0;
0393  0140     MOVLB 0x0
0394  1198     BCF LATA, 0x3
87:                    __delay_us(100);
0395  3085     MOVLW 0x85
0396  0B89     DECFSZ WREG, F
0397  2B96     GOTO 0x396
0398  0000     NOP
88:                }
0399  3001     MOVLW 0x1
039A  00F0     MOVWF __pcstackCOMMON
039B  0870     MOVF __pcstackCOMMON, W
039C  07F1     ADDWF str, F
039D  300A     MOVLW 0xA
039E  0271     SUBWF str, W
039F  1C03     BTFSS STATUS, 0x0
03A0  2BA2     GOTO 0x3A2
03A1  2BA3     GOTO 0x3A3
03A2  2B8A     GOTO 0x38A
89:                        
90:                TRISAbits.TRISA3 = 1;       // Set RA3 as an input pin
03A3  0140     MOVLB 0x0
03A4  1592     BSF TRISA, 0x3
91:                ANSELAbits.ANSA3 = 1;       // Set RA3 as an analog signal
03A5  017D     MOVLB 0x3D
03A6  158C     BSF ANSELA, 0x3
92:            }
03A7  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/Polled_Input.c
1:             /*
2:              * File:   Polled_Input.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:32 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "Polled_Input.h"
11:            #include "Basic_Init.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:            void Polled_Input_Calculations(void){  
15:                uint24_t pulse_count = 0;
05FA  3000     MOVLW 0x0
05FB  0140     MOVLB 0x0
05FC  00CF     MOVWF pulse_count
05FD  3000     MOVLW 0x0
05FE  00D0     MOVWF 0x50
05FF  3000     MOVLW 0x0
0600  00D1     MOVWF 0x51
16:                uint24_t period_count = 0;
0601  3000     MOVLW 0x0
0602  00D2     MOVWF period_count
0603  3000     MOVLW 0x0
0604  00D3     MOVWF 0x53
0605  3000     MOVLW 0x0
0606  00D4     MOVWF pulse_width_high
17:                uint8_t period_countH = 0;
18:                uint8_t period_countL = 0;
19:                uint8_t pulse_countH = 0;
20:                uint8_t pulse_countL = 0;
21:                uint8_t duty_cycle = 0;
22:                
23:                while(PORTBbits.RB5 == HIGH);                   // Wait for the input signal to go high
0607  1A8D     BTFSC PORTB, 0x5
0608  2E0A     GOTO 0x60A
0609  2E0B     GOTO 0x60B
060A  2E07     GOTO 0x607
24:                while(PORTBbits.RB5 == LOW);                    // Wait for the input signal to go low
060B  1E8D     BTFSS PORTB, 0x5
060C  2E0E     GOTO 0x60E
060D  2E0F     GOTO 0x60F
060E  2E0B     GOTO 0x60B
060F  2E19     GOTO 0x619
25:                while(PORTBbits.RB5 == HIGH){                   
0619  1A8D     BTFSC PORTB, 0x5
061A  2E1C     GOTO 0x61C
061B  2E1D     GOTO 0x61D
061C  2E10     GOTO 0x610
061D  2E27     GOTO 0x627
26:                    pulse_count = pulse_count + 1;              // While the input signal is high increment pulse_count
0610  3001     MOVLW 0x1
0611  074F     ADDWF pulse_count, W
0612  00CF     MOVWF pulse_count
0613  3000     MOVLW 0x0
0614  3D50     ADDWFC 0x50, W
0615  00D0     MOVWF 0x50
0616  3000     MOVLW 0x0
0617  3D51     ADDWFC 0x51, W
0618  00D1     MOVWF 0x51
27:                }
28:                while(PORTBbits.RB5 == LOW){                     
0627  1E8D     BTFSS PORTB, 0x5
0628  2E2A     GOTO 0x62A
0629  2E2B     GOTO 0x62B
062A  2E1E     GOTO 0x61E
29:                    period_count = period_count + 1;            // While the input signal is low increment period_count
061E  3001     MOVLW 0x1
061F  0752     ADDWF period_count, W
0620  00D2     MOVWF period_count
0621  3000     MOVLW 0x0
0622  3D53     ADDWFC 0x53, W
0623  00D3     MOVWF 0x53
0624  3000     MOVLW 0x0
0625  3D54     ADDWFC pulse_width_high, W
0626  00D4     MOVWF pulse_width_high
30:                }
31:            
32:                period_count = period_count + pulse_count;      // Add up the pulse and period counts to make the correct period count
062B  0852     MOVF period_count, W
062C  074F     ADDWF pulse_count, W
062D  00C6     MOVWF __pcstackBANK0
062E  0853     MOVF 0x53, W
062F  3D50     ADDWFC 0x50, W
0630  00C7     MOVWF 0x47
0631  0854     MOVF pulse_width_high, W
0632  3D51     ADDWFC 0x51, W
0633  00C8     MOVWF start
0634  0846     MOVF __pcstackBANK0, W
0635  00D2     MOVWF period_count
0636  0847     MOVF 0x47, W
0637  00D3     MOVWF 0x53
0638  0848     MOVF start, W
0639  00D4     MOVWF pulse_width_high
33:            
34:                period_countH = (period_count & 0xFF00) >> 8;   // Split the period count into a high and low byte
063A  0852     MOVF period_count, W
063B  00C6     MOVWF __pcstackBANK0
063C  0853     MOVF 0x53, W
063D  00C7     MOVWF 0x47
063E  0854     MOVF pulse_width_high, W
063F  00C8     MOVWF start
0640  3008     MOVLW 0x8
0641  36C8     LSRF start, F
0642  0CC7     RRF 0x47, F
0643  0CC6     RRF __pcstackBANK0, F
0644  0B89     DECFSZ WREG, F
0645  2E41     GOTO 0x641
0646  0846     MOVF __pcstackBANK0, W
0647  00C9     MOVWF TMR0_val
0648  0849     MOVF TMR0_val, W
0649  00CA     MOVWF period_countH
35:                period_countL = (period_count & 0xFF);          
064A  0852     MOVF period_count, W
064B  00C6     MOVWF __pcstackBANK0
064C  0846     MOVF __pcstackBANK0, W
064D  00CB     MOVWF period_countL
36:                pulse_countH = (pulse_count & 0xFF00) >> 8;     // Split the pulse count into a high and low byte
064E  084F     MOVF pulse_count, W
064F  00C6     MOVWF __pcstackBANK0
0650  0850     MOVF 0x50, W
0651  00C7     MOVWF 0x47
0652  0851     MOVF 0x51, W
0653  00C8     MOVWF start
0654  3008     MOVLW 0x8
0655  36C8     LSRF start, F
0656  0CC7     RRF 0x47, F
0657  0CC6     RRF __pcstackBANK0, F
0658  0B89     DECFSZ WREG, F
0659  2E55     GOTO 0x655
065A  0846     MOVF __pcstackBANK0, W
065B  00C9     MOVWF TMR0_val
065C  0849     MOVF TMR0_val, W
065D  00CC     MOVWF pulse_countH
37:                pulse_countL = (pulse_count & 0xFF);            
065E  084F     MOVF pulse_count, W
065F  00C6     MOVWF __pcstackBANK0
0660  0846     MOVF __pcstackBANK0, W
0661  00CD     MOVWF pulse_countL
38:            
39:                duty_cycle = (pulse_count << 8)/ period_count;  // Calculate the duty cycle
0662  0852     MOVF period_count, W
0663  00F0     MOVWF __pcstackCOMMON
0664  0853     MOVF 0x53, W
0665  00F1     MOVWF str
0666  0854     MOVF pulse_width_high, W
0667  00F2     MOVWF number
0668  084F     MOVF pulse_count, W
0669  00C6     MOVWF __pcstackBANK0
066A  0850     MOVF 0x50, W
066B  00C7     MOVWF 0x47
066C  0851     MOVF 0x51, W
066D  00C8     MOVWF start
066E  3008     MOVLW 0x8
066F  35C6     LSLF __pcstackBANK0, F
0670  0DC7     RLF 0x47, F
0671  0DC8     RLF start, F
0672  0B89     DECFSZ WREG, F
0673  2E6F     GOTO 0x66F
0674  0846     MOVF __pcstackBANK0, W
0675  00F3     MOVWF module
0676  0847     MOVF 0x47, W
0677  00F4     MOVWF pulse_countL
0678  0848     MOVF start, W
0679  00F5     MOVWF period_countH
067A  318F     MOVLP 0xF
067B  27B4     CALL 0x7B4
067C  3185     MOVLP 0x5
067D  0870     MOVF __pcstackCOMMON, W
067E  0140     MOVLB 0x0
067F  00C9     MOVWF TMR0_val
0680  0849     MOVF TMR0_val, W
0681  00CE     MOVWF duty_cycle
40:                
41:                EUSART1_sendAllData(pulse_countH, pulse_countL, period_countH, period_countL, duty_cycle);  //Send data over UART
0682  084D     MOVF pulse_countL, W
0683  00C6     MOVWF __pcstackBANK0
0684  0846     MOVF __pcstackBANK0, W
0685  00F4     MOVWF pulse_countL
0686  084A     MOVF period_countH, W
0687  00C7     MOVWF 0x47
0688  0847     MOVF 0x47, W
0689  00F5     MOVWF period_countH
068A  084B     MOVF period_countL, W
068B  00C8     MOVWF start
068C  0848     MOVF start, W
068D  00F6     MOVWF period_countL
068E  084E     MOVF duty_cycle, W
068F  00C9     MOVWF TMR0_val
0690  0849     MOVF TMR0_val, W
0691  00F7     MOVWF readVal
0692  084C     MOVF pulse_countH, W
0693  318E     MOVLP 0xE
0694  26D5     CALL 0x6D5
0695  3185     MOVLP 0x5
42:            
43:                pulse_count = 0;                                
44:                period_count = 0;                               
45:            
46:                __delay_ms(1);                                  // Wait for 1ms
0696  3006     MOVLW 0x6
0697  0140     MOVLB 0x0
0698  00C6     MOVWF __pcstackBANK0
0699  3030     MOVLW 0x30
069A  0B89     DECFSZ WREG, F
069B  2E9A     GOTO 0x69A
069C  0BC6     DECFSZ __pcstackBANK0, F
069D  2E9A     GOTO 0x69A
069E  0000     NOP
47:            }
069F  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/IOC_wo_Timer.c
1:             /*
2:              * File:   IOC_wo_Timer.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:32 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "IOC_wo_Timer.h"
11:            #include "Basic_Init.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:            void IOC_wo_Timer_Calculations(void){
15:                IOC_wo_Timer_Initialize();                              // Run the IOC without Timer Initialization function
0538  318A     MOVLP 0xA
0539  2282     CALL 0x282
053A  3185     MOVLP 0x5
16:                uint24_t pulse_count = 0;
053B  3000     MOVLW 0x0
053C  0140     MOVLB 0x0
053D  00CF     MOVWF pulse_count
053E  3000     MOVLW 0x0
053F  00D0     MOVWF 0x50
0540  3000     MOVLW 0x0
0541  00D1     MOVWF 0x51
17:                uint24_t period_count = 0;
0542  3000     MOVLW 0x0
0543  00D2     MOVWF period_count
0544  3000     MOVLW 0x0
0545  00D3     MOVWF 0x53
0546  3000     MOVLW 0x0
0547  00D4     MOVWF pulse_width_high
18:                uint8_t period_countH = 0;
19:                uint8_t period_countL = 0;
20:                uint8_t pulse_countH = 0;
21:                uint8_t pulse_countL = 0;
22:                uint8_t duty_cycle = 0;
23:                IOCBFbits.IOCBF5 = 0;                                   // Clear the RB5 IOC Flag
0548  017D     MOVLB 0x3D
0549  129D     BCF IOCBF, 0x5
24:                
25:                while(PORTBbits.RB5 == LOW)                             // Wait for the input signal to go low
26:                ;                                                       // Silences a warning
054A  0140     MOVLB 0x0
054B  1E8D     BTFSS PORTB, 0x5
054C  2D4E     GOTO 0x54E
054D  2D4F     GOTO 0x54F
054E  2D4A     GOTO 0x54A
27:                while(PORTBbits.RB5 == HIGH);                           // Wait for the input signal to go high       
054F  1A8D     BTFSC PORTB, 0x5
0550  2D52     GOTO 0x552
0551  2D53     GOTO 0x553
0552  2D4F     GOTO 0x54F
28:                IOCBFbits.IOCBF5 = 0;                                
0553  017D     MOVLB 0x3D
0554  129D     BCF IOCBF, 0x5
29:                while(!IOCBFbits.IOCBF5);                               // Wait for the the RB5 IOC Flag to be triggered 
0555  1E9D     BTFSS IOCBF, 0x5
0556  2D58     GOTO 0x558
0557  2D59     GOTO 0x559
0558  2D55     GOTO 0x555
0559  2D7D     GOTO 0x57D
30:                while(IOCBFbits.IOCBF5){                                
31:                    IOCBFbits.IOCBF5 = 0;                             
055A  129D     BCF IOCBF, 0x5
32:            
33:                    while(!IOCBFbits.IOCBF5){                           
055B  2D66     GOTO 0x566
0566  017D     MOVLB 0x3D
0567  1E9D     BTFSS IOCBF, 0x5
0568  2D6A     GOTO 0x56A
0569  2D6B     GOTO 0x56B
056A  2D5C     GOTO 0x55C
34:                        pulse_count = pulse_count + 1;                  // While the RB5 IOC Flag is low, increment the pulse_count
055C  3001     MOVLW 0x1
055D  0140     MOVLB 0x0
055E  074F     ADDWF pulse_count, W
055F  00CF     MOVWF pulse_count
0560  3000     MOVLW 0x0
0561  3D50     ADDWFC 0x50, W
0562  00D0     MOVWF 0x50
0563  3000     MOVLW 0x0
0564  3D51     ADDWFC 0x51, W
0565  00D1     MOVWF 0x51
35:                    }
36:                    IOCBFbits.IOCBF5 = 0;   
056B  129D     BCF 0x1D, 0x5
37:                    while(!IOCBFbits.IOCBF5){
056C  2D77     GOTO 0x577
0577  017D     MOVLB 0x3D
0578  1E9D     BTFSS IOCBF, 0x5
0579  2D7B     GOTO 0x57B
057A  2D7C     GOTO 0x57C
057B  2D6D     GOTO 0x56D
38:                        period_count = period_count + 1;                // While the RB5 IOC Flag is low, increment the period_count
056D  3001     MOVLW 0x1
056E  0140     MOVLB 0x0
056F  0752     ADDWF period_count, W
0570  00D2     MOVWF period_count
0571  3000     MOVLW 0x0
0572  3D53     ADDWFC 0x53, W
0573  00D3     MOVWF 0x53
0574  3000     MOVLW 0x0
0575  3D54     ADDWFC pulse_width_high, W
0576  00D4     MOVWF pulse_width_high
39:                    }
40:                    IOCBFbits.IOCBF5 = 0;
057C  129D     BCF 0x1D, 0x5
41:                }
057D  1A9D     BTFSC 0x1D, 0x5
057E  2D80     GOTO 0x580
057F  2D81     GOTO 0x581
0580  2D5A     GOTO 0x55A
42:            
43:                period_count = period_count + pulse_count;              // Add up the pulse and the period counts to make the correct period count
0581  0140     MOVLB 0x0
0582  0852     MOVF period_count, W
0583  074F     ADDWF pulse_count, W
0584  00C6     MOVWF __pcstackBANK0
0585  0853     MOVF 0x53, W
0586  3D50     ADDWFC 0x50, W
0587  00C7     MOVWF 0x47
0588  0854     MOVF pulse_width_high, W
0589  3D51     ADDWFC 0x51, W
058A  00C8     MOVWF start
058B  0846     MOVF __pcstackBANK0, W
058C  00D2     MOVWF period_count
058D  0847     MOVF 0x47, W
058E  00D3     MOVWF 0x53
058F  0848     MOVF start, W
0590  00D4     MOVWF pulse_width_high
44:            
45:                period_countH = (period_count & 0xFF00) >> 8;           // Split the period count into a high and low byte
0591  0852     MOVF period_count, W
0592  00C6     MOVWF __pcstackBANK0
0593  0853     MOVF 0x53, W
0594  00C7     MOVWF 0x47
0595  0854     MOVF pulse_width_high, W
0596  00C8     MOVWF start
0597  3008     MOVLW 0x8
0598  36C8     LSRF start, F
0599  0CC7     RRF 0x47, F
059A  0CC6     RRF __pcstackBANK0, F
059B  0B89     DECFSZ WREG, F
059C  2D98     GOTO 0x598
059D  0846     MOVF __pcstackBANK0, W
059E  00C9     MOVWF TMR0_val
059F  0849     MOVF TMR0_val, W
05A0  00CA     MOVWF period_countH
46:                period_countL = (period_count & 0xFF);
05A1  0852     MOVF period_count, W
05A2  00C6     MOVWF __pcstackBANK0
05A3  0846     MOVF __pcstackBANK0, W
05A4  00CB     MOVWF period_countL
47:                pulse_countH = (pulse_count & 0xFF00) >> 8;             // Split the pulse count into a high and low byte
05A5  084F     MOVF pulse_count, W
05A6  00C6     MOVWF __pcstackBANK0
05A7  0850     MOVF 0x50, W
05A8  00C7     MOVWF 0x47
05A9  0851     MOVF 0x51, W
05AA  00C8     MOVWF start
05AB  3008     MOVLW 0x8
05AC  36C8     LSRF start, F
05AD  0CC7     RRF 0x47, F
05AE  0CC6     RRF __pcstackBANK0, F
05AF  0B89     DECFSZ WREG, F
05B0  2DAC     GOTO 0x5AC
05B1  0846     MOVF __pcstackBANK0, W
05B2  00C9     MOVWF TMR0_val
05B3  0849     MOVF TMR0_val, W
05B4  00CC     MOVWF pulse_countH
48:                pulse_countL = (pulse_count & 0xFF);
05B5  084F     MOVF pulse_count, W
05B6  00C6     MOVWF __pcstackBANK0
05B7  0846     MOVF __pcstackBANK0, W
05B8  00CD     MOVWF pulse_countL
49:            
50:                duty_cycle = (pulse_count << 8)/ period_count;          // Calculate the duty cycle
05B9  0852     MOVF period_count, W
05BA  00F0     MOVWF __pcstackCOMMON
05BB  0853     MOVF 0x53, W
05BC  00F1     MOVWF str
05BD  0854     MOVF pulse_width_high, W
05BE  00F2     MOVWF number
05BF  084F     MOVF pulse_count, W
05C0  00C6     MOVWF __pcstackBANK0
05C1  0850     MOVF 0x50, W
05C2  00C7     MOVWF 0x47
05C3  0851     MOVF 0x51, W
05C4  00C8     MOVWF start
05C5  3008     MOVLW 0x8
05C6  35C6     LSLF __pcstackBANK0, F
05C7  0DC7     RLF 0x47, F
05C8  0DC8     RLF start, F
05C9  0B89     DECFSZ WREG, F
05CA  2DC6     GOTO 0x5C6
05CB  0846     MOVF __pcstackBANK0, W
05CC  00F3     MOVWF module
05CD  0847     MOVF 0x47, W
05CE  00F4     MOVWF pulse_countL
05CF  0848     MOVF start, W
05D0  00F5     MOVWF period_countH
05D1  318F     MOVLP 0xF
05D2  27B4     CALL 0x7B4
05D3  3185     MOVLP 0x5
05D4  0870     MOVF __pcstackCOMMON, W
05D5  0140     MOVLB 0x0
05D6  00C9     MOVWF TMR0_val
05D7  0849     MOVF TMR0_val, W
05D8  00CE     MOVWF duty_cycle
51:            
52:                EUSART1_sendAllData(pulse_countH, pulse_countL, period_countH, period_countL, duty_cycle); // Send data over UART
05D9  084D     MOVF pulse_countL, W
05DA  00C6     MOVWF __pcstackBANK0
05DB  0846     MOVF __pcstackBANK0, W
05DC  00F4     MOVWF pulse_countL
05DD  084A     MOVF period_countH, W
05DE  00C7     MOVWF 0x47
05DF  0847     MOVF 0x47, W
05E0  00F5     MOVWF period_countH
05E1  084B     MOVF period_countL, W
05E2  00C8     MOVWF start
05E3  0848     MOVF start, W
05E4  00F6     MOVWF period_countL
05E5  084E     MOVF duty_cycle, W
05E6  00C9     MOVWF TMR0_val
05E7  0849     MOVF TMR0_val, W
05E8  00F7     MOVWF readVal
05E9  084C     MOVF pulse_countH, W
05EA  318E     MOVLP 0xE
05EB  26D5     CALL 0x6D5
05EC  3185     MOVLP 0x5
53:            
54:                pulse_count = 0;
55:                period_count = 0;
56:            
57:                __delay_ms(1);                                          // Wait for 1ms
05ED  3006     MOVLW 0x6
05EE  0140     MOVLB 0x0
05EF  00C6     MOVWF __pcstackBANK0
05F0  3030     MOVLW 0x30
05F1  0B89     DECFSZ WREG, F
05F2  2DF1     GOTO 0x5F1
05F3  0BC6     DECFSZ __pcstackBANK0, F
05F4  2DF1     GOTO 0x5F1
05F5  0000     NOP
58:            
59:                IOC_Reset();                                            // Reset IOC changes
05F6  3187     MOVLP 0x7
05F7  27FC     CALL 0x7FC
05F8  3185     MOVLP 0x5
60:            }
05F9  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/IOC_w_Timer.c
1:             /*
2:              * File:   IOC_w_Timer.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:32 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "IOC_w_Timer.h"
11:            #include "Basic_Init.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:            void IOC_w_Timer_Calculations(void){
15:                IOC_w_Timer_Initialize();                               // Run the IOC with Timer Initialization function
0473  318A     MOVLP 0xA
0474  22AE     CALL 0x2AE
0475  3184     MOVLP 0x4
16:                uint24_t pulse_count = 0;
0476  3000     MOVLW 0x0
0477  0140     MOVLB 0x0
0478  00CF     MOVWF pulse_count
0479  3000     MOVLW 0x0
047A  00D0     MOVWF 0x50
047B  3000     MOVLW 0x0
047C  00D1     MOVWF 0x51
17:                uint24_t period_count = 0;
047D  3000     MOVLW 0x0
047E  00D2     MOVWF period_count
047F  3000     MOVLW 0x0
0480  00D3     MOVWF 0x53
0481  3000     MOVLW 0x0
0482  00D4     MOVWF pulse_width_high
18:                uint8_t period_countH = 0;
19:                uint8_t period_countL = 0;
20:                uint8_t pulse_countH = 0;
21:                uint8_t pulse_countL = 0;
22:                uint8_t duty_cycle = 0;
23:                IOCBFbits.IOCBF5 = 0;                                   // Clear the RB5 IOC Flag
0483  017D     MOVLB 0x3D
0484  129D     BCF IOCBF, 0x5
24:                TMR0L = 0;                                              // Clear Timer0 Low byte
0485  0143     MOVLB 0x3
0486  019C     CLRF TMR0L
25:                TMR0H = 0;                                              // Clear Timer0 High byte
0487  019D     CLRF TMR0H
26:            
27:                while(PORTBbits.RB5 == LOW);                            // Wait for the input signal to go low
0488  0140     MOVLB 0x0
0489  1E8D     BTFSS PORTB, 0x5
048A  2C8C     GOTO 0x48C
048B  2C8D     GOTO 0x48D
048C  2C88     GOTO 0x488
28:                while(PORTBbits.RB5 == HIGH);                           // Wait for the input signal to go high 
048D  1A8D     BTFSC PORTB, 0x5
048E  2C90     GOTO 0x490
048F  2C91     GOTO 0x491
0490  2C8D     GOTO 0x48D
29:                IOCBFbits.IOCBF5 = 0;
0491  017D     MOVLB 0x3D
0492  129D     BCF IOCBF, 0x5
30:                while(!IOCBFbits.IOCBF5);                               // Wait for the RB5 IOC Flag to be triggered 
0493  1E9D     BTFSS IOCBF, 0x5
0494  2C96     GOTO 0x496
0495  2C97     GOTO 0x497
0496  2C93     GOTO 0x493
0497  2CC3     GOTO 0x4C3
31:                while(IOCBFbits.IOCBF5){
04C3  017D     MOVLB 0x3D
04C4  1A9D     BTFSC IOCBF, 0x5
04C5  2CC7     GOTO 0x4C7
04C6  2CC8     GOTO 0x4C8
04C7  2C98     GOTO 0x498
32:                    IOCBFbits.IOCBF5 = 0;
0498  129D     BCF IOCBF, 0x5
33:                    Timer0_Start();                                     // Start Timer0
0499  318A     MOVLP 0xA
049A  2243     CALL 0x243
049B  3184     MOVLP 0x4
34:                    while(!IOCBFbits.IOCBF5);
049C  017D     MOVLB 0x3D
049D  1E9D     BTFSS IOCBF, 0x5
049E  2CA0     GOTO 0x4A0
049F  2CA1     GOTO 0x4A1
04A0  2C9C     GOTO 0x49C
35:                    IOCBFbits.IOCBF5 = 0;
04A1  129D     BCF IOCBF, 0x5
36:                    Timer0_Stop();                                      // Stop Timer0
04A2  318A     MOVLP 0xA
04A3  2240     CALL 0x240
04A4  3184     MOVLP 0x4
37:                    pulse_count = Timer0_Read();                        // Set the pulse count to equal the Timer0 count
04A5  318D     MOVLP 0xD
04A6  2599     CALL 0x599
04A7  3184     MOVLP 0x4
04A8  0870     MOVF 0x1EF0, W
04A9  0140     MOVLB 0x0
04AA  00CF     MOVWF pulse_count
04AB  0871     MOVF str, W
04AC  00D0     MOVWF 0x50
04AD  01D1     CLRF 0x51
38:                    Timer0_Start();
04AE  318A     MOVLP 0xA
04AF  2243     CALL 0x243
04B0  3184     MOVLP 0x4
39:                    while(!IOCBFbits.IOCBF5);
04B1  017D     MOVLB 0x3D
04B2  1E9D     BTFSS IOCBF, 0x5
04B3  2CB5     GOTO 0x4B5
04B4  2CB6     GOTO 0x4B6
04B5  2CB1     GOTO 0x4B1
40:                    IOCBFbits.IOCBF5 = 0;
04B6  129D     BCF IOCBF, 0x5
41:                    Timer0_Stop();
04B7  318A     MOVLP 0xA
04B8  2240     CALL 0x240
04B9  3184     MOVLP 0x4
42:                    period_count = Timer0_Read();                       // Set the period count to equal the Timer0 count
04BA  318D     MOVLP 0xD
04BB  2599     CALL 0x599
04BC  3184     MOVLP 0x4
04BD  0870     MOVF 0x1EF0, W
04BE  0140     MOVLB 0x0
04BF  00D2     MOVWF period_count
04C0  0871     MOVF str, W
04C1  00D3     MOVWF 0x53
04C2  01D4     CLRF pulse_width_high
43:                }
44:                    
45:                    period_countH = (period_count & 0xFF00) >> 8;       // Split the period count into a high and low byte
04C8  0140     MOVLB 0x0
04C9  0852     MOVF period_count, W
04CA  00C6     MOVWF __pcstackBANK0
04CB  0853     MOVF 0x53, W
04CC  00C7     MOVWF 0x47
04CD  0854     MOVF pulse_width_high, W
04CE  00C8     MOVWF start
04CF  3008     MOVLW 0x8
04D0  36C8     LSRF start, F
04D1  0CC7     RRF 0x47, F
04D2  0CC6     RRF __pcstackBANK0, F
04D3  0B89     DECFSZ WREG, F
04D4  2CD0     GOTO 0x4D0
04D5  0846     MOVF __pcstackBANK0, W
04D6  00C9     MOVWF TMR0_val
04D7  0849     MOVF TMR0_val, W
04D8  00CA     MOVWF period_countH
46:                    period_countL = (period_count & 0xFF);
04D9  0852     MOVF period_count, W
04DA  00C6     MOVWF __pcstackBANK0
04DB  0846     MOVF __pcstackBANK0, W
04DC  00CB     MOVWF period_countL
47:                    pulse_countH = (pulse_count & 0xFF00) >> 8;         // Split the pulse count into a high and low byte
04DD  084F     MOVF pulse_count, W
04DE  00C6     MOVWF __pcstackBANK0
04DF  0850     MOVF 0x50, W
04E0  00C7     MOVWF 0x47
04E1  0851     MOVF 0x51, W
04E2  00C8     MOVWF start
04E3  3008     MOVLW 0x8
04E4  36C8     LSRF start, F
04E5  0CC7     RRF 0x47, F
04E6  0CC6     RRF __pcstackBANK0, F
04E7  0B89     DECFSZ WREG, F
04E8  2CE4     GOTO 0x4E4
04E9  0846     MOVF __pcstackBANK0, W
04EA  00C9     MOVWF TMR0_val
04EB  0849     MOVF TMR0_val, W
04EC  00CC     MOVWF pulse_countH
48:                    pulse_countL = (pulse_count & 0xFF);
04ED  084F     MOVF pulse_count, W
04EE  00C6     MOVWF __pcstackBANK0
04EF  0846     MOVF __pcstackBANK0, W
04F0  00CD     MOVWF pulse_countL
49:                    
50:                    duty_cycle = (pulse_count << 8)/ period_count;      // Calculate the duty cycle
04F1  0852     MOVF period_count, W
04F2  00F0     MOVWF __pcstackCOMMON
04F3  0853     MOVF 0x53, W
04F4  00F1     MOVWF str
04F5  0854     MOVF pulse_width_high, W
04F6  00F2     MOVWF number
04F7  084F     MOVF pulse_count, W
04F8  00C6     MOVWF __pcstackBANK0
04F9  0850     MOVF 0x50, W
04FA  00C7     MOVWF 0x47
04FB  0851     MOVF 0x51, W
04FC  00C8     MOVWF start
04FD  3008     MOVLW 0x8
04FE  35C6     LSLF __pcstackBANK0, F
04FF  0DC7     RLF 0x47, F
0500  0DC8     RLF start, F
0501  0B89     DECFSZ WREG, F
0502  2CFE     GOTO 0x4FE
0503  0846     MOVF __pcstackBANK0, W
0504  00F3     MOVWF module
0505  0847     MOVF 0x47, W
0506  00F4     MOVWF pulse_countL
0507  0848     MOVF start, W
0508  00F5     MOVWF period_countH
0509  318F     MOVLP 0xF
050A  27B4     CALL 0x7B4
050B  3184     MOVLP 0x4
050C  0870     MOVF __pcstackCOMMON, W
050D  0140     MOVLB 0x0
050E  00C9     MOVWF TMR0_val
050F  0849     MOVF TMR0_val, W
0510  00CE     MOVWF duty_cycle
51:                    
52:                    EUSART1_sendAllData(pulse_countH, pulse_countL, period_countH, period_countL, duty_cycle);  //Send data over UART
0511  084D     MOVF pulse_countL, W
0512  00C6     MOVWF __pcstackBANK0
0513  0846     MOVF __pcstackBANK0, W
0514  00F4     MOVWF pulse_countL
0515  084A     MOVF period_countH, W
0516  00C7     MOVWF 0x47
0517  0847     MOVF 0x47, W
0518  00F5     MOVWF period_countH
0519  084B     MOVF period_countL, W
051A  00C8     MOVWF start
051B  0848     MOVF start, W
051C  00F6     MOVWF period_countL
051D  084E     MOVF duty_cycle, W
051E  00C9     MOVWF TMR0_val
051F  0849     MOVF TMR0_val, W
0520  00F7     MOVWF readVal
0521  084C     MOVF pulse_countH, W
0522  318E     MOVLP 0xE
0523  26D5     CALL 0x6D5
0524  3184     MOVLP 0x4
53:            
54:                    pulse_count = 0;    
55:                    period_count = 0;
56:                    TMR0L = 0;
0525  0143     MOVLB 0x3
0526  019C     CLRF TMR0L
57:                    TMR0H = 0;
0527  019D     CLRF TMR0H
58:            
59:                    __delay_ms(1);                                      // Wait for 1ms
0528  3006     MOVLW 0x6
0529  0140     MOVLB 0x0
052A  00C6     MOVWF __pcstackBANK0
052B  3030     MOVLW 0x30
052C  0B89     DECFSZ WREG, F
052D  2D2C     GOTO 0x52C
052E  0BC6     DECFSZ __pcstackBANK0, F
052F  2D2C     GOTO 0x52C
0530  0000     NOP
60:            
61:                IOC_Reset();                                            // Reset IOC Changes
0531  3187     MOVLP 0x7
0532  27FC     CALL 0x7FC
0533  3184     MOVLP 0x4
62:                TMR0_Reset();                                           // Reset TMR0 Changes
0534  318A     MOVLP 0xA
0535  22A0     CALL 0x2A0
0536  3184     MOVLP 0x4
63:            }
0537  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/CLC_NCO.c
1:             /*
2:              * File:   CLC_NCO.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:31 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "CLC_NCO.h"
11:            #include "Basic_Init.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:            void send_NCO_measurement(void){                            // Send NCO Accumulator U/H/L bytes over UART 
15:                EUSART1_sendInt(NCO1ACCU);                              
0B70  0149     MOVLB 0x9
0B71  080E     MOVF NCO1ACCU, W
0B72  318B     MOVLP 0xB
0B73  2390     CALL 0x390
0B74  318B     MOVLP 0xB
16:                EUSART1_sendInt(NCO1ACCH);                              
0B75  0149     MOVLB 0x9
0B76  080D     MOVF NCO1ACCH, W
0B77  318B     MOVLP 0xB
0B78  2390     CALL 0x390
0B79  318B     MOVLP 0xB
17:                EUSART1_sendInt(NCO1ACCL);                              
0B7A  0149     MOVLB 0x9
0B7B  080C     MOVF NCO1ACC, W
0B7C  318B     MOVLP 0xB
0B7D  2390     CALL 0x390
0B7E  318B     MOVLP 0xB
18:            }
0B7F  0008     RETURN
19:            void send_TMR0_measurement(void){                           // Send Timer0 H/L bytes over UART 
20:                EUSART1_sendInt(TMR0H);                                 
0AD8  0143     MOVLB 0x3
0AD9  081D     MOVF TMR0H, W
0ADA  318B     MOVLP 0xB
0ADB  2390     CALL 0x390
0ADC  318A     MOVLP 0xA
21:                EUSART1_sendInt(TMR0L);                                 
0ADD  0143     MOVLB 0x3
0ADE  081C     MOVF TMR0L, W
0ADF  318B     MOVLP 0xB
0AE0  2390     CALL 0x390
0AE1  318A     MOVLP 0xA
22:            }
0AE2  0008     RETURN
23:            void send_TMR1_measurement(void){                           // Send Timer1 H/L bytes over UART  
24:                EUSART1_sendInt(TMR1H);                                 
0ACD  0145     MOVLB 0x5
0ACE  080D     MOVF TMR1H, W
0ACF  318B     MOVLP 0xB
0AD0  2390     CALL 0x390
0AD1  318A     MOVLP 0xA
25:                EUSART1_sendInt(TMR1L);                                 
0AD2  0145     MOVLB 0x5
0AD3  080C     MOVF TMR1, W
0AD4  318B     MOVLP 0xB
0AD5  2390     CALL 0x390
0AD6  318A     MOVLP 0xA
26:            }
0AD7  0008     RETURN
27:            void clear_NCO_Accumulator(void){                           // Clear NCO1 Accumulator U/H/L bytes                               
28:                NCO1ACCU = 0x00;                                        
0A55  0149     MOVLB 0x9
0A56  018E     CLRF NCO1ACCU
29:                NCO1ACCH = 0x00;                                        
0A57  018D     CLRF NCO1ACCH
30:                NCO1ACCL = 0x00;                                        
0A58  018C     CLRF NCO1ACC
31:            }
0A59  0008     RETURN
32:            void clear_TMR0_Value(void){                                // Clear Timer0 H/L bytes
33:                TMR0H = 0xFF;                                           
0A5F  30FF     MOVLW 0xFF
0A60  0143     MOVLB 0x3
0A61  009D     MOVWF TMR0H
34:                TMR0L = 0x00;                                           
0A62  019C     CLRF TMR0L
35:            }
0A63  0008     RETURN
36:            void clear_TMR1_Value(void){                                // Clear Timer1 H/L bytes  
37:                TMR1H = 0x00;                                           
0A5A  0145     MOVLB 0x5
0A5B  018D     CLRF TMR1H
38:                TMR1L = 0x01;                                           
0A5C  3001     MOVLW 0x1
0A5D  008C     MOVWF TMR1
39:            }
0A5E  0008     RETURN
40:            void MAX_TMR1_Value(void){                                  // Set Maximum values to Timer1 H/L bytes 
41:                TMR1H = 0xFF;                                           
0A76  30FF     MOVLW 0xFF
0A77  0145     MOVLB 0x5
0A78  008D     MOVWF TMR1H
42:                TMR1L = 0xFF;                                           
0A79  30FF     MOVLW 0xFF
0A7A  008C     MOVWF TMR1
43:            }
0A7B  0008     RETURN
44:            void send_DC_Calculation_CLCNCO1_CLCNCO2(void){             // Calculate the duty cycle and output as an 8-bit value, 0-255 = 0-100%, e.g. 127 = 50%
45:                uint24_t NCO_val = 0;                                   
076B  3000     MOVLW 0x0
076C  0140     MOVLB 0x0
076D  00C6     MOVWF __pcstackBANK0
076E  3000     MOVLW 0x0
076F  00C7     MOVWF 0x47
0770  3000     MOVLW 0x0
0771  00C8     MOVWF start
46:                uint24_t TMR1_val = 0;                                  
0772  3000     MOVLW 0x0
0773  00C9     MOVWF TMR0_val
0774  3000     MOVLW 0x0
0775  00CA     MOVWF period_countH
0776  3000     MOVLW 0x0
0777  00CB     MOVWF period_countL
47:                uint24_t duty_cycle = 0;                                
48:                
49:                NCO_val = ((NCO1ACCH << 8) + NCO1ACCL);                 // Combine the NCOACCH/L bytes into a 16-bit value by left shifting the High byte by 8
0778  0149     MOVLB 0x9
0779  080C     MOVF NCO1ACC, W
077A  0140     MOVLB 0x0
077B  00C6     MOVWF __pcstackBANK0
077C  0149     MOVLB 0x9
077D  080D     MOVF NCO1ACCH, W
077E  0140     MOVLB 0x0
077F  00C7     MOVWF 0x47
0780  0D89     RLF WREG, F
0781  3B89     SUBWFB WREG, F
0782  0989     COMF WREG, F
0783  00C8     MOVWF start
50:                TMR1_val = ((TMR1H << 8) + TMR1L);                      // Combine the TMR1H/L bytes into a 16-bit value by left shifting the High byte by 8
0784  0145     MOVLB 0x5
0785  080C     MOVF TMR1, W
0786  0140     MOVLB 0x0
0787  00C9     MOVWF TMR0_val
0788  0145     MOVLB 0x5
0789  080D     MOVF TMR1H, W
078A  0140     MOVLB 0x0
078B  00CA     MOVWF period_countH
078C  0D89     RLF WREG, F
078D  3B89     SUBWFB WREG, F
078E  0989     COMF WREG, F
078F  00CB     MOVWF period_countL
51:            
52:                duty_cycle = (NCO_val << 8)/TMR1_val;                   // Calculate the duty cycle by left shifting the NCO_val by 8 (effectively multiplying by 256), then dividing by the TMR1_val
0790  0849     MOVF TMR0_val, W
0791  00F0     MOVWF __pcstackCOMMON
0792  084A     MOVF period_countH, W
0793  00F1     MOVWF str
0794  084B     MOVF period_countL, W
0795  00F2     MOVWF number
0796  0846     MOVF __pcstackBANK0, W
0797  00FB     MOVWF 0x7B
0798  0847     MOVF 0x47, W
0799  00FC     MOVWF 0x7C
079A  0848     MOVF start, W
079B  00FD     MOVWF 0x7D
079C  3008     MOVLW 0x8
079D  35FB     LSLF 0x7B, F
079E  0DFC     RLF 0x7C, F
079F  0DFD     RLF 0x7D, F
07A0  0B89     DECFSZ WREG, F
07A1  2F9D     GOTO 0x79D
07A2  087B     MOVF 0x7B, W
07A3  00F3     MOVWF module
07A4  087C     MOVF 0x7C, W
07A5  00F4     MOVWF pulse_countL
07A6  087D     MOVF 0x7D, W
07A7  00F5     MOVWF period_countH
07A8  318F     MOVLP 0xF
07A9  27B4     CALL 0x7B4
07AA  3187     MOVLP 0x7
07AB  0870     MOVF __pcstackCOMMON, W
07AC  0140     MOVLB 0x0
07AD  00CC     MOVWF pulse_countH
07AE  0871     MOVF str, W
07AF  00CD     MOVWF pulse_countL
07B0  0872     MOVF number, W
07B1  00CE     MOVWF duty_cycle
53:                
54:                EUSART1_sendInt(duty_cycle);                            // Send the duty cycle value over UART
07B2  084C     MOVF pulse_countH, W
07B3  318B     MOVLP 0xB
07B4  2390     CALL 0x390
07B5  3187     MOVLP 0x7
55:            }
07B6  0008     RETURN
56:            void send_DC_Calculation_CLCNCO3(void){                     // Calculate the duty cycle and output as an 8-bit value, 0-255 = 0-100%, e.g. 127 = 50%
57:                uint24_t TMR0_val = 0;                                  
06A0  3000     MOVLW 0x0
06A1  0140     MOVLB 0x0
06A2  00C9     MOVWF TMR0_val
06A3  3000     MOVLW 0x0
06A4  00CA     MOVWF period_countH
06A5  3000     MOVLW 0x0
06A6  00CB     MOVWF period_countL
58:                uint24_t TMR1_val = 0;                                  
06A7  3000     MOVLW 0x0
06A8  00CC     MOVWF pulse_countH
06A9  3000     MOVLW 0x0
06AA  00CD     MOVWF pulse_countL
06AB  3000     MOVLW 0x0
06AC  00CE     MOVWF duty_cycle
59:                uint24_t duty_cycle = 0;                                
60:                
61:                TMR0_val = (TMR0L);                                     // Update the TMR0_val to equal the TMR0L value
06AD  0143     MOVLB 0x3
06AE  081C     MOVF TMR0L, W
06AF  00FB     MOVWF 0x1FB
06B0  01FC     CLRF 0x1FC
06B1  01FD     CLRF 0x1FD
06B2  087B     MOVF 0x1FB, W
06B3  0140     MOVLB 0x0
06B4  00C9     MOVWF TMR0_val
06B5  087C     MOVF 0x7C, W
06B6  00CA     MOVWF period_countH
06B7  087D     MOVF 0x7D, W
06B8  00CB     MOVWF period_countL
62:                TMR1_val = ((TMR1H << 8) + TMR1L);                      // Combine the TMR1H/L bytes into a 16-bit value by left shifting the High byte by 8
06B9  0145     MOVLB 0x5
06BA  080C     MOVF TMR1, W
06BB  0140     MOVLB 0x0
06BC  00CC     MOVWF pulse_countH
06BD  0145     MOVLB 0x5
06BE  080D     MOVF TMR1H, W
06BF  0140     MOVLB 0x0
06C0  00CD     MOVWF pulse_countL
06C1  0D89     RLF WREG, F
06C2  3B89     SUBWFB WREG, F
06C3  0989     COMF WREG, F
06C4  00CE     MOVWF duty_cycle
63:            
64:                TMR0_val = (TMR0_val << 8);                             // Update the TMR0_val to equal the prior TMR0_val value left shifted by 8
06C5  0849     MOVF TMR0_val, W
06C6  00FB     MOVWF 0x7B
06C7  084A     MOVF period_countH, W
06C8  00FC     MOVWF 0x7C
06C9  084B     MOVF period_countL, W
06CA  00FD     MOVWF 0x7D
06CB  3008     MOVLW 0x8
06CC  35FB     LSLF 0x7B, F
06CD  0DFC     RLF 0x7C, F
06CE  0DFD     RLF 0x7D, F
06CF  0B89     DECFSZ WREG, F
06D0  2ECC     GOTO 0x6CC
06D1  087B     MOVF 0x7B, W
06D2  00C9     MOVWF TMR0_val
06D3  087C     MOVF 0x7C, W
06D4  00CA     MOVWF period_countH
06D5  087D     MOVF 0x7D, W
06D6  00CB     MOVWF period_countL
65:                TMR1_val = (TMR1_val >> 6);                             // Update the TMR1_val to equal the prior TMR1_val value right shifted by 6
06D7  084C     MOVF pulse_countH, W
06D8  00FB     MOVWF 0x7B
06D9  084D     MOVF pulse_countL, W
06DA  00FC     MOVWF 0x7C
06DB  084E     MOVF duty_cycle, W
06DC  00FD     MOVWF 0x7D
06DD  3006     MOVLW 0x6
06DE  36FD     LSRF 0x7D, F
06DF  0CFC     RRF 0x7C, F
06E0  0CFB     RRF 0x7B, F
06E1  0B89     DECFSZ WREG, F
06E2  2EDE     GOTO 0x6DE
06E3  087B     MOVF 0x7B, W
06E4  00CC     MOVWF pulse_countH
06E5  087C     MOVF 0x7C, W
06E6  00CD     MOVWF pulse_countL
06E7  087D     MOVF 0x7D, W
06E8  00CE     MOVWF duty_cycle
66:                  
67:                if (PIR1bits.TMR1IF){                                   // If the Timer1 Interrupt Flag is high do the following:
06E9  0141     MOVLB 0x1
06EA  1D8D     BTFSS PIR1, 0x3
06EB  2EED     GOTO 0x6ED
06EC  2EEE     GOTO 0x6EE
06ED  2F00     GOTO 0x700
68:                    TMR0_val = (TMR0L);                                 // 1) set the Timer0 value to the TMR0L byte
06EE  0143     MOVLB 0x3
06EF  081C     MOVF TMR0L, W
06F0  00FB     MOVWF 0x1FB
06F1  01FC     CLRF 0x1FC
06F2  01FD     CLRF 0x1FD
06F3  087B     MOVF 0x1FB, W
06F4  0140     MOVLB 0x0
06F5  00C9     MOVWF TMR0_val
06F6  087C     MOVF 0x7C, W
06F7  00CA     MOVWF period_countH
06F8  087D     MOVF 0x7D, W
06F9  00CB     MOVWF period_countL
69:                    TMR1_val = 0x01;                                    // 2) set the Timer1 value to 0x01
06FA  3001     MOVLW 0x1
06FB  00CC     MOVWF pulse_countH
06FC  3000     MOVLW 0x0
06FD  00CD     MOVWF pulse_countL
06FE  3000     MOVLW 0x0
06FF  00CE     MOVWF duty_cycle
70:                } 
71:                
72:                duty_cycle = TMR0_val/TMR1_val;                         // Calculate the duty cycle by dividing the TMR0 value by the TMR1 value
0700  0140     MOVLB 0x0
0701  084C     MOVF pulse_countH, W
0702  00F0     MOVWF __pcstackCOMMON
0703  084D     MOVF pulse_countL, W
0704  00F1     MOVWF str
0705  084E     MOVF duty_cycle, W
0706  00F2     MOVWF number
0707  0849     MOVF TMR0_val, W
0708  00F3     MOVWF module
0709  084A     MOVF period_countH, W
070A  00F4     MOVWF pulse_countL
070B  084B     MOVF period_countL, W
070C  00F5     MOVWF period_countH
070D  318F     MOVLP 0xF
070E  27B4     CALL 0x7B4
070F  3186     MOVLP 0x6
0710  0870     MOVF __pcstackCOMMON, W
0711  0140     MOVLB 0x0
0712  00C6     MOVWF __pcstackBANK0
0713  0871     MOVF str, W
0714  00C7     MOVWF 0x47
0715  0872     MOVF number, W
0716  00C8     MOVWF start
73:                
74:                EUSART1_sendInt(duty_cycle);                            // Send duty cycle value over UART
0717  0846     MOVF __pcstackBANK0, W
0718  318B     MOVLP 0xB
0719  2390     CALL 0x390
071A  3186     MOVLP 0x6
75:            }
071B  0008     RETURN
76:            void send_DC_Calculation_MT(void){                          // Calculate the duty cycle and output as an 8-bit value, 0-255 = 0-100%, e.g. 127 = 50%
77:                uint24_t NCO_val = 0;                                   
0F00  3000     MOVLW 0x0
0F01  0140     MOVLB 0x0
0F02  00C6     MOVWF __pcstackBANK0
0F03  3000     MOVLW 0x0
0F04  00C7     MOVWF 0x47
0F05  3000     MOVLW 0x0
0F06  00C8     MOVWF start
78:                uint24_t TMR1_val = 0;                                  
0F07  3000     MOVLW 0x0
0F08  00C9     MOVWF TMR0_val
0F09  3000     MOVLW 0x0
0F0A  00CA     MOVWF period_countH
0F0B  3000     MOVLW 0x0
0F0C  00CB     MOVWF period_countL
79:                uint24_t duty_cycle = 0;                                
80:                    
81:                TMR1_val = 0x3F;                                        // Set the TMR1_val as the maximum for one period (based on 1MHz input signal)
0F0D  303F     MOVLW 0x3F
0F0E  00C9     MOVWF TMR0_val
0F0F  3000     MOVLW 0x0
0F10  00CA     MOVWF period_countH
0F11  3000     MOVLW 0x0
0F12  00CB     MOVWF period_countL
82:                NCO_val = ((NCO1ACCH << 8) + NCO1ACCL);                 // Combine the NCOACCH/L bytes into a 16-bit value by left shifting the High byte by 8
0F13  0149     MOVLB 0x9
0F14  080C     MOVF NCO1ACC, W
0F15  0140     MOVLB 0x0
0F16  00C6     MOVWF __pcstackBANK0
0F17  0149     MOVLB 0x9
0F18  080D     MOVF NCO1ACCH, W
0F19  0140     MOVLB 0x0
0F1A  00C7     MOVWF 0x47
0F1B  0D89     RLF WREG, F
0F1C  3B89     SUBWFB WREG, F
0F1D  0989     COMF WREG, F
0F1E  00C8     MOVWF start
83:                
84:                duty_cycle = NCO_val/TMR1_val;                          // Calculate the duty cycle by dividing the NCO1 value by the TMR1 value
0F1F  303F     MOVLW 0x3F
0F20  00F0     MOVWF __pcstackCOMMON
0F21  3000     MOVLW 0x0
0F22  00F1     MOVWF str
0F23  3000     MOVLW 0x0
0F24  00F2     MOVWF number
0F25  0846     MOVF __pcstackBANK0, W
0F26  00F3     MOVWF module
0F27  0847     MOVF 0x47, W
0F28  00F4     MOVWF pulse_countL
0F29  0848     MOVF start, W
0F2A  00F5     MOVWF period_countH
0F2B  318F     MOVLP 0xF
0F2C  27B4     CALL 0x7B4
0F2D  318F     MOVLP 0xF
0F2E  0870     MOVF __pcstackCOMMON, W
0F2F  0140     MOVLB 0x0
0F30  00CC     MOVWF pulse_countH
0F31  0871     MOVF str, W
0F32  00CD     MOVWF pulse_countL
0F33  0872     MOVF number, W
0F34  00CE     MOVWF duty_cycle
85:                
86:                EUSART1_sendInt(duty_cycle);                            // Send duty cycle value over UART
0F35  084C     MOVF pulse_countH, W
0F36  318B     MOVLP 0xB
0F37  2390     CALL 0x390
0F38  318F     MOVLP 0xF
87:            }
0F39  0008     RETURN
88:            void send_measurement_CLCNCO1_CLCNCO2(void){                
89:                EUSART1_sendString("\nPULSE:");                         // Send pulse data (NCO value) over UART
0DD4  3050     MOVLW 0x50
0DD5  00F1     MOVWF str
0DD6  3091     MOVLW 0x91
0DD7  00F2     MOVWF number
0DD8  318E     MOVLP 0xE
0DD9  26B3     CALL 0x6B3
0DDA  318D     MOVLP 0xD
90:                send_NCO_measurement();                                 
0DDB  318B     MOVLP 0xB
0DDC  2370     CALL 0x370
0DDD  318D     MOVLP 0xD
91:                EUSART1_sendString("\nPD:");                            // Send period data (Timer1 value)over UART
0DDE  3069     MOVLW 0x69
0DDF  00F1     MOVWF str
0DE0  3091     MOVLW 0x91
0DE1  00F2     MOVWF number
0DE2  318E     MOVLP 0xE
0DE3  26B3     CALL 0x6B3
0DE4  318D     MOVLP 0xD
92:                send_TMR1_measurement();                                
0DE5  318A     MOVLP 0xA
0DE6  22CD     CALL 0x2CD
0DE7  318D     MOVLP 0xD
93:                EUSART1_sendString("\nDC:");                            // Send duty cycle data over UART
0DE8  3064     MOVLW 0x64
0DE9  00F1     MOVWF str
0DEA  3091     MOVLW 0x91
0DEB  00F2     MOVWF number
0DEC  318E     MOVLP 0xE
0DED  26B3     CALL 0x6B3
0DEE  318D     MOVLP 0xD
94:                send_DC_Calculation_CLCNCO1_CLCNCO2();                  
0DEF  3187     MOVLP 0x7
0DF0  276B     CALL 0x76B
0DF1  318D     MOVLP 0xD
95:            }
0DF2  0008     RETURN
96:            void send_measurement_CLCNCO3(void){ 
97:                EUSART1_sendString("\nPULSE:");                         // Send pulse data (Timer0 value) over UART
0E12  3050     MOVLW 0x50
0E13  00F1     MOVWF str
0E14  3091     MOVLW 0x91
0E15  00F2     MOVWF number
0E16  318E     MOVLP 0xE
0E17  26B3     CALL 0x6B3
0E18  318E     MOVLP 0xE
98:                send_TMR0_measurement();                                
0E19  318A     MOVLP 0xA
0E1A  22D8     CALL 0x2D8
0E1B  318E     MOVLP 0xE
99:                EUSART1_sendString("\nPD:");                            // Send period data (Timer1 value)over UART
0E1C  3069     MOVLW 0x69
0E1D  00F1     MOVWF str
0E1E  3091     MOVLW 0x91
0E1F  00F2     MOVWF number
0E20  318E     MOVLP 0xE
0E21  26B3     CALL 0x6B3
0E22  318E     MOVLP 0xE
100:               send_TMR1_measurement();                                
0E23  318A     MOVLP 0xA
0E24  22CD     CALL 0x2CD
0E25  318E     MOVLP 0xE
101:               EUSART1_sendString("\nDC:");                            // Send duty cycle data over UART
0E26  3064     MOVLW 0x64
0E27  00F1     MOVWF str
0E28  3091     MOVLW 0x91
0E29  00F2     MOVWF number
0E2A  318E     MOVLP 0xE
0E2B  26B3     CALL 0x6B3
0E2C  318E     MOVLP 0xE
102:               send_DC_Calculation_CLCNCO3();                          
0E2D  3186     MOVLP 0x6
0E2E  26A0     CALL 0x6A0
0E2F  318E     MOVLP 0xE
103:           }
0E30  0008     RETURN
104:           void send_measurement_MT(void){                             // MT means 'Max Timer'
105:               EUSART1_sendString("\nPULSE:");                         // Send pulse data (NCO value) over UART
0DF3  3050     MOVLW 0x50
0DF4  00F1     MOVWF str
0DF5  3091     MOVLW 0x91
0DF6  00F2     MOVWF number
0DF7  318E     MOVLP 0xE
0DF8  26B3     CALL 0x6B3
0DF9  318D     MOVLP 0xD
106:               send_NCO_measurement();                                 
0DFA  318B     MOVLP 0xB
0DFB  2370     CALL 0x370
0DFC  318D     MOVLP 0xD
107:               EUSART1_sendString("\nPD:"); //Timer1                   // Send period data (Timer1 value) over UART
0DFD  3069     MOVLW 0x69
0DFE  00F1     MOVWF str
0DFF  3091     MOVLW 0x91
0E00  00F2     MOVWF number
0E01  318E     MOVLP 0xE
0E02  26B3     CALL 0x6B3
0E03  318D     MOVLP 0xD
108:               send_TMR1_measurement();                                
0E04  318A     MOVLP 0xA
0E05  22CD     CALL 0x2CD
0E06  318D     MOVLP 0xD
109:               EUSART1_sendString("\nDC:");                            // Send duty cycle data over UART
0E07  3064     MOVLW 0x64
0E08  00F1     MOVWF str
0E09  3091     MOVLW 0x91
0E0A  00F2     MOVWF number
0E0B  318E     MOVLP 0xE
0E0C  26B3     CALL 0x6B3
0E0D  318D     MOVLP 0xD
110:               send_DC_Calculation_MT();                               
0E0E  318F     MOVLP 0xF
0E0F  2700     CALL 0x700
0E10  318D     MOVLP 0xD
111:           }
0E11  0008     RETURN
112:           void clear_flags_CLCNCO1_CLCNCO2(void){                     // Clear Timer1 and NCO1 Interrupt Flags, and set cycles back to 0
113:               PIR1bits.TMR1IF = 0;                                    
0A4D  0141     MOVLB 0x1
0A4E  118D     BCF PIR1, 0x3
114:               PIR2bits.NCO1IF = 0;                                    
0A4F  120E     BCF PIR2, 0x4
115:               uint16_t cycles = 0;                                    
116:           }
0A50  0008     RETURN
117:           void clear_flags_CLCNCO3(void){                             // Clear Timer0 and Timer1 Interrupt Flags, and set cycles back to 0
118:               PIR1bits.TMR1IF = 0;                                    
0A51  0141     MOVLB 0x1
0A52  118D     BCF PIR1, 0x3
119:               PIR0bits.TMR0IF = 0;                                    
0A53  128C     BCF PIR0, 0x5
120:               uint16_t cycles = 0;                                    
121:           }
0A54  0008     RETURN
122:           void reset_CLC2_CLC3(void){                                 
123:               CLCSELECT = 0x1;                                        // Select CLC2
0B05  3001     MOVLW 0x1
0B06  014B     MOVLB 0xB
0B07  0096     MOVWF CLCSELECT
124:               CLCnPOLbits.G3POL = HIGH;                               // Set the Gate 3 polarity high
0B08  150D     BSF CLCnPOL, 0x2
125:               CLCSELECT = 0x2;                                        // Select CLC3
0B09  3002     MOVLW 0x2
0B0A  0096     MOVWF CLCSELECT
126:               CLCnPOLbits.G3POL = HIGH;                               // Set the Gate 3 polarity high
0B0B  150D     BSF CLCnPOL, 0x2
127:               CLCnPOLbits.G3POL = LOW;                                // Set the Gate 3 polarity low
0B0C  110D     BCF CLCnPOL, 0x2
128:               CLCSELECT = 0x1;                                        // Select CLC2
0B0D  3001     MOVLW 0x1
0B0E  0096     MOVWF CLCSELECT
129:               CLCnPOLbits.G3POL = LOW;                                // Set the Gate 3 polarity low
0B0F  110D     BCF CLCnPOL, 0x2
130:           }
0B10  0008     RETURN
131:           void setup_for_new_measurement_CLCNCO1(void){               // Clear NCO1 Accumulator, Timer1 Value, Various Interrupt Flags
132:               clear_NCO_Accumulator();                                
0B61  318A     MOVLP 0xA
0B62  2255     CALL 0x255
0B63  318B     MOVLP 0xB
133:               clear_TMR1_Value();                                     
0B64  318A     MOVLP 0xA
0B65  225A     CALL 0x25A
0B66  318B     MOVLP 0xB
134:               clear_flags_CLCNCO1_CLCNCO2();                       
0B67  318A     MOVLP 0xA
0B68  224D     CALL 0x24D
0B69  318B     MOVLP 0xB
135:               
136:               Timer1_Start();                                         // Start Timer1
0B6A  318A     MOVLP 0xA
0B6B  223A     CALL 0x23A
0B6C  318B     MOVLP 0xB
137:               NCO1CONbits.EN = 1;                                     // Enable NCO
0B6D  0149     MOVLB 0x9
0B6E  1792     BSF NCO1CON, 0x7
138:           }   
0B6F  0008     RETURN
139:           void setup_for_new_measurement_CLCNCO2(void){               // Clear NCO1 Accumulator, Timer1 Value, Various Interrupt Flags, and Reset CLC2 and CLC3
140:               clear_NCO_Accumulator();                                
0BA1  318A     MOVLP 0xA
0BA2  2255     CALL 0x255
0BA3  318B     MOVLP 0xB
141:               clear_TMR1_Value();                                     
0BA4  318A     MOVLP 0xA
0BA5  225A     CALL 0x25A
0BA6  318B     MOVLP 0xB
142:               clear_flags_CLCNCO1_CLCNCO2();                          
0BA7  318A     MOVLP 0xA
0BA8  224D     CALL 0x24D
0BA9  318B     MOVLP 0xB
143:               reset_CLC2_CLC3();                                      
0BAA  318B     MOVLP 0xB
0BAB  2305     CALL 0x305
0BAC  318B     MOVLP 0xB
144:               
145:               Timer1_Start();                                         // Start Timer1
0BAD  318A     MOVLP 0xA
0BAE  223A     CALL 0x23A
0BAF  318B     MOVLP 0xB
146:               NCO1CONbits.EN = 1;                                     // Enable NCO
0BB0  0149     MOVLB 0x9
0BB1  1792     BSF NCO1CON, 0x7
147:           }
0BB2  0008     RETURN
148:           void setup_for_new_measurement_CLCNCO3(void){               // Clear Timer0 Value, Timer1 Value, Various Interrupt Flags, and Reset CLC2 and CLC3
149:               clear_TMR0_Value();                                     
0BEB  318A     MOVLP 0xA
0BEC  225F     CALL 0x25F
0BED  318B     MOVLP 0xB
150:               clear_TMR1_Value();                                     
0BEE  318A     MOVLP 0xA
0BEF  225A     CALL 0x25A
0BF0  318B     MOVLP 0xB
151:               clear_flags_CLCNCO3();                                  
0BF1  318A     MOVLP 0xA
0BF2  2251     CALL 0x251
0BF3  318B     MOVLP 0xB
152:               reset_CLC2_CLC3();                                      
0BF4  318B     MOVLP 0xB
0BF5  2305     CALL 0x305
0BF6  318B     MOVLP 0xB
153:                       
154:               Timer0_Start();                                         // Start Timer0
0BF7  318A     MOVLP 0xA
0BF8  2243     CALL 0x243
0BF9  318B     MOVLP 0xB
155:               Timer1_Start();                                         // Start Timer1
0BFA  318A     MOVLP 0xA
0BFB  223A     CALL 0x23A
0BFC  318B     MOVLP 0xB
156:           }
0BFD  0008     RETURN
157:           
158:           uint16_t cycles = 0;                                        
159:           
160:           void CLC_NCO1_Calculations(void){
0F3A  0141     MOVLB 0x1
0F3B  198D     BTFSC PIR1, 0x3
0F3C  2F3E     GOTO 0x73E
0F3D  2F3F     GOTO 0x73F
0F3E  2F4D     GOTO 0x74D
0F3F  1A0E     BTFSC PIR2, 0x4
0F40  2F42     GOTO 0x742
0F41  2F43     GOTO 0x743
0F42  2F4D     GOTO 0x74D
0F43  3000     MOVLW 0x0
0F44  0140     MOVLB 0x0
0F45  022F     SUBWF 0x2F, W
0F46  3064     MOVLW 0x64
161:               if (PIR1bits.TMR1IF || PIR2bits.NCO1IF || cycles > 99){ // Check that one of the following is true: Timer1 Interrupt Flag, NCO1 Interrupt Flag, cycles > 99
0F47  1903     BTFSC STATUS, 0x2
0F48  022E     SUBWF cycles, W
0F49  1C03     BTFSS STATUS, 0x0
0F4A  2F4C     GOTO 0x74C
0F4B  2F4D     GOTO 0x74D
0F4C  2F68     GOTO 0x768
162:                   if (PIR1bits.TMR1IF){                               // Check if Timer1 Interrupt Flag is high
0F4D  0141     MOVLB 0x1
0F4E  1D8D     BTFSS PIR1, 0x3
0F4F  2F51     GOTO 0x751
0F50  2F52     GOTO 0x752
0F51  2F5E     GOTO 0x75E
163:                       NCO1CONbits.EN = 0;                             // Stop NCO1
0F52  0149     MOVLB 0x9
0F53  1392     BCF NCO1CON, 0x7
164:                       Timer1_Stop();                                  // Stop Timer1
0F54  318A     MOVLP 0xA
0F55  223D     CALL 0x23D
0F56  318F     MOVLP 0xF
165:           
166:                       send_measurement_CLCNCO1_CLCNCO2();             // Send measurement information over UART
0F57  318D     MOVLP 0xD
0F58  25D4     CALL 0x5D4
0F59  318F     MOVLP 0xF
167:                       setup_for_new_measurement_CLCNCO1();            // Setup for the next measurement
0F5A  318B     MOVLP 0xB
0F5B  2361     CALL 0x361
0F5C  318F     MOVLP 0xF
168:                   }
0F5D  2F6C     GOTO 0x76C
169:                   else if (PIR2bits.NCO1IF){                          // Check if NCO1 Interrupt Flag is high
0F5E  1E0E     BTFSS NCO1ACCU, 0x4
0F5F  2F61     GOTO 0x761
0F60  2F62     GOTO 0x762
0F61  2F65     GOTO 0x765
170:                       NCO1CONbits.EN = 0;                             
0F62  0149     MOVLB 0x9
0F63  1392     BCF NCO1CON, 0x7
0F64  2F54     GOTO 0x754
171:                       Timer1_Stop();                                  
172:           
173:                       send_measurement_CLCNCO1_CLCNCO2();             
174:                       setup_for_new_measurement_CLCNCO1();            
175:                   }
176:                   else{                                               // Check if cycles > 99
177:                       NCO1CONbits.EN = 0;                             
0F65  0149     MOVLB 0x9
0F66  1392     BCF NCO1CON, 0x7
0F67  2F54     GOTO 0x754
178:                       Timer1_Stop();                                  
179:           
180:                       send_measurement_CLCNCO1_CLCNCO2();             
181:                       setup_for_new_measurement_CLCNCO1();            
182:                   }
183:               }
184:               else{
185:                   cycles++;                                           // Increment cycles
0F68  3001     MOVLW 0x1
0F69  07AE     ADDWF 0x4AE, F
0F6A  3000     MOVLW 0x0
0F6B  3DAF     ADDWFC 0x4AF, F
186:               }    
187:              __delay_ms(1);                                           // Wait for 1ms
0F6C  3006     MOVLW 0x6
0F6D  0140     MOVLB 0x0
0F6E  00CF     MOVWF pulse_count
0F6F  3030     MOVLW 0x30
0F70  0B89     DECFSZ WREG, F
0F71  2F70     GOTO 0x770
0F72  0BCF     DECFSZ pulse_count, F
0F73  2F70     GOTO 0x770
0F74  0000     NOP
188:           }
0F75  0008     RETURN
189:           void CLC_NCO2_Calculations(void){
07B7  0141     MOVLB 0x1
07B8  198D     BTFSC PIR1, 0x3
07B9  2FBB     GOTO 0x7BB
07BA  2FBC     GOTO 0x7BC
07BB  2FCA     GOTO 0x7CA
07BC  1A0E     BTFSC PIR2, 0x4
07BD  2FBF     GOTO 0x7BF
07BE  2FC0     GOTO 0x7C0
07BF  2FCA     GOTO 0x7CA
07C0  3000     MOVLW 0x0
07C1  0140     MOVLB 0x0
07C2  022F     SUBWF 0x2F, W
07C3  3064     MOVLW 0x64
190:               if (PIR1bits.TMR1IF || PIR2bits.NCO1IF || cycles > 99){ // Check that one of the following is true: Timer1 Interrupt Flag, NCO1 Interrupt Flag, cycles > 99
07C4  1903     BTFSC STATUS, 0x2
07C5  022E     SUBWF cycles, W
07C6  1C03     BTFSS STATUS, 0x0
07C7  2FC9     GOTO 0x7C9
07C8  2FCA     GOTO 0x7CA
07C9  2FEE     GOTO 0x7EE
191:                   if (PIR1bits.TMR1IF){                               // Check if Timer1 Interrupt Flag is high
07CA  0141     MOVLB 0x1
07CB  1D8D     BTFSS PIR1, 0x3
07CC  2FCE     GOTO 0x7CE
07CD  2FCF     GOTO 0x7CF
07CE  2FDE     GOTO 0x7DE
192:                       NCO1CONbits.EN = 0;                             // Stop NCO1
07CF  0149     MOVLB 0x9
07D0  1392     BCF NCO1CON, 0x7
193:                       Timer1_Stop();                                  // Stop Timer1
07D1  318A     MOVLP 0xA
07D2  223D     CALL 0x23D
07D3  3187     MOVLP 0x7
194:                       MAX_TMR1_Value();                               // Set Timer1 to maximum values
07D4  318A     MOVLP 0xA
07D5  2276     CALL 0x276
07D6  3187     MOVLP 0x7
195:                       send_measurement_MT();                          // Send measurement information over UART (MT means 'Max Timer')
07D7  318D     MOVLP 0xD
07D8  25F3     CALL 0x5F3
07D9  3187     MOVLP 0x7
196:                       setup_for_new_measurement_CLCNCO2();            // Setup for the next measurement
07DA  318B     MOVLP 0xB
07DB  23A1     CALL 0x3A1
07DC  3187     MOVLP 0x7
197:                   }
07DD  2FF2     GOTO 0x7F2
198:                   else if (PIR2bits.NCO1IF){                          // Check if NCO1 Interrupt Flag is high
07DE  1E0E     BTFSS NCO1ACCU, 0x4
07DF  2FE1     GOTO 0x7E1
07E0  2FE2     GOTO 0x7E2
07E1  2FEB     GOTO 0x7EB
199:                       NCO1CONbits.EN = 0;                             
07E2  0149     MOVLB 0x9
07E3  1392     BCF NCO1CON, 0x7
200:                       Timer1_Stop();                                  
07E4  318A     MOVLP 0xA
07E5  223D     CALL 0x23D
07E6  3187     MOVLP 0x7
201:                       send_measurement_CLCNCO1_CLCNCO2();             // Send measurement information over UART
07E7  318D     MOVLP 0xD
07E8  25D4     CALL 0x5D4
07E9  3187     MOVLP 0x7
07EA  2FDA     GOTO 0x7DA
202:                       setup_for_new_measurement_CLCNCO2();            
203:                   }
204:                   else{                                               // Check if cycles > 99
205:                       NCO1CONbits.EN = 0;                             
07EB  0149     MOVLB 0x9
07EC  1392     BCF NCO1CON, 0x7
07ED  2FE4     GOTO 0x7E4
206:                       Timer1_Stop();                                  
207:                       send_measurement_CLCNCO1_CLCNCO2();             
208:                       setup_for_new_measurement_CLCNCO2();            
209:                   }
210:               }
211:               else{
212:                   cycles++;                                           // Increment cycles
07EE  3001     MOVLW 0x1
07EF  07AE     ADDWF 0x4AE, F
07F0  3000     MOVLW 0x0
07F1  3DAF     ADDWFC 0x4AF, F
213:               }
214:              __delay_ms(1);                                           // Wait for 1ms
07F2  3006     MOVLW 0x6
07F3  0140     MOVLB 0x0
07F4  00CF     MOVWF pulse_count
07F5  3030     MOVLW 0x30
07F6  0B89     DECFSZ WREG, F
07F7  2FF6     GOTO 0x7F6
07F8  0BCF     DECFSZ pulse_count, F
07F9  2FF6     GOTO 0x7F6
07FA  0000     NOP
215:           }
07FB  0008     RETURN
216:           void CLC_NCO3_Calculations(void){
0F76  0141     MOVLB 0x1
0F77  198D     BTFSC PIR1, 0x3
0F78  2F7A     GOTO 0x77A
0F79  2F7B     GOTO 0x77B
0F7A  2F89     GOTO 0x789
0F7B  1A8C     BTFSC PIR0, 0x5
0F7C  2F7E     GOTO 0x77E
0F7D  2F7F     GOTO 0x77F
0F7E  2F89     GOTO 0x789
0F7F  3003     MOVLW 0x3
0F80  0140     MOVLB 0x0
0F81  022F     SUBWF 0x2F, W
0F82  30E8     MOVLW 0xE8
217:               if (PIR1bits.TMR1IF || PIR0bits.TMR0IF || cycles > 999){// Check that one of the following is true: Timer1 Interrupt Flag, Timer0 Interrupt Flag, cycles > 999
0F83  1903     BTFSC STATUS, 0x2
0F84  022E     SUBWF cycles, W
0F85  1C03     BTFSS STATUS, 0x0
0F86  2F88     GOTO 0x788
0F87  2F89     GOTO 0x789
0F88  2FA6     GOTO 0x7A6
218:                       if (PIR1bits.TMR1IF){                           // Check if Timer1 Interrupt Flag is high
0F89  0141     MOVLB 0x1
0F8A  1D8D     BTFSS PIR1, 0x3
0F8B  2F8D     GOTO 0x78D
0F8C  2F8E     GOTO 0x78E
0F8D  2F9E     GOTO 0x79E
219:                           Timer0_Stop();                              // Stop Timer0
0F8E  318A     MOVLP 0xA
0F8F  2240     CALL 0x240
0F90  318F     MOVLP 0xF
220:                           Timer1_Stop();                              // Stop Timer1
0F91  318A     MOVLP 0xA
0F92  223D     CALL 0x23D
0F93  318F     MOVLP 0xF
221:                           MAX_TMR1_Value();                           // Set Timer1 to maximum values
0F94  318A     MOVLP 0xA
0F95  2276     CALL 0x276
0F96  318F     MOVLP 0xF
222:                           send_measurement_CLCNCO3();                 // Send measurement information over UART
0F97  318E     MOVLP 0xE
0F98  2612     CALL 0x612
0F99  318F     MOVLP 0xF
223:                           setup_for_new_measurement_CLCNCO3();        // Setup for the next measurement
0F9A  318B     MOVLP 0xB
0F9B  23EB     CALL 0x3EB
0F9C  318F     MOVLP 0xF
224:                       }
0F9D  2FAA     GOTO 0x7AA
225:                       else if (PIR0bits.TMR0IF){                      // Check if Timer0 Interrupt Flag is high
0F9E  080C     MOVF PIR0, W
226:                           Timer0_Stop();                              
0F9F  318A     MOVLP 0xA
0FA0  2240     CALL 0x240
0FA1  318F     MOVLP 0xF
227:                           Timer1_Stop();                              
0FA2  318A     MOVLP 0xA
0FA3  223D     CALL 0x23D
0FA4  318F     MOVLP 0xF
0FA5  2F97     GOTO 0x797
228:                           send_measurement_CLCNCO3();                 
229:                           setup_for_new_measurement_CLCNCO3();        
230:                       }       
231:                       else{                                           // Check if cycles > 999
232:                           Timer0_Stop();                              
233:                           Timer1_Stop();                              
234:                           send_measurement_CLCNCO3();                 
235:                           setup_for_new_measurement_CLCNCO3();        
236:                       }
237:                   }
238:                   else{
239:                       cycles++;                                       // Increment cycles
0FA6  3001     MOVLW 0x1
0FA7  07AE     ADDWF 0xAE, F
0FA8  3000     MOVLW 0x0
0FA9  3DAF     ADDWFC 0xAF, F
240:                   }
241:                  __delay_ms(2);                                       // Wait for 2ms
0FAA  300B     MOVLW 0xB
0FAB  0140     MOVLB 0x0
0FAC  00CF     MOVWF pulse_count
0FAD  3062     MOVLW 0x62
0FAE  0B89     DECFSZ WREG, F
0FAF  2FAE     GOTO 0x7AE
0FB0  0BCF     DECFSZ pulse_count, F
0FB1  2FAE     GOTO 0x7AE
0FB2  0000     NOP
242:               }    
0FB3  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/CCP.c
1:             /*
2:              * File:   CCP.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:31 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "CCP.h"
11:            #include "Basic_Init.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:                uint24_t pulse_count = 0;
15:                uint24_t period_count = 0;
16:                uint8_t duty_cycle = 0;
17:                uint16_t value1 = 0;
18:                uint16_t value2 = 0;
19:                uint16_t value3 = 0;
20:                uint16_t value4 = 0;
21:            
22:            void CCP_Calculations(void){
23:                CCP1CONbits.EN = 1;                                         // Enable CCP1
019B  0147     MOVLB 0x7
019C  178E     BSF CCP1CON, 0x7
24:                Timer1_Start();                                             // Start Timer1
019D  318A     MOVLP 0xA
019E  223A     CALL 0x23A
019F  3181     MOVLP 0x1
25:            
26:                while(!PIR2bits.CCP1IF);                                    // Wait until the CCP1 Interrupt Flag is set
01A0  0141     MOVLB 0x1
01A1  1D0E     BTFSS PIR2, 0x2
01A2  29A4     GOTO 0x1A4
01A3  29A5     GOTO 0x1A5
01A4  29A0     GOTO 0x1A0
27:            
28:                CCP1CONbits.EN = 0;                                         // Disable CCP1
01A5  0147     MOVLB 0x7
01A6  138E     BCF CCP1CON, 0x7
29:                PIR2bits.CCP1IF = 0;                                        // Clear the CCP1 Interrupt Flag
01A7  0141     MOVLB 0x1
01A8  110E     BCF PIR2, 0x2
30:            
31:                value1 = CCP1_CaptureRead();                                // Set value1 to be the current CCP1 value
01A9  318B     MOVLP 0xB
01AA  2336     CALL 0x336
01AB  3181     MOVLP 0x1
01AC  0871     MOVF 0xF1, W
01AD  0140     MOVLB 0x0
01AE  00AD     MOVWF 0x2D
01AF  0870     MOVF __pcstackCOMMON, W
01B0  00AC     MOVWF value1
32:            
33:                CCP1CONbits.EN = 1;                                         
01B1  0147     MOVLB 0x7
01B2  178E     BSF CCP1CON, 0x7
34:                CCP2CONbits.EN = 1;                                         // Enable CCP2
01B3  1792     BSF CCP2CON, 0x7
35:            
36:                while(!PIR2bits.CCP2IF);                                    // Wait until the CCP2 Interrupt Flag is set
01B4  0141     MOVLB 0x1
01B5  1D8E     BTFSS PIR2, 0x3
01B6  29B8     GOTO 0x1B8
01B7  29B9     GOTO 0x1B9
01B8  29B4     GOTO 0x1B4
37:                CCP2CONbits.EN = 0;                                         // Disable CCP2
01B9  0147     MOVLB 0x7
01BA  1392     BCF CCP2CON, 0x7
38:                PIR2bits.CCP2IF = 0;                                        // Clear the CCP2 Interrupt Flag
01BB  0141     MOVLB 0x1
01BC  118E     BCF PIR2, 0x3
39:                CCP2CONbits.EN = 1;
01BD  0147     MOVLB 0x7
01BE  1792     BSF CCP2CON, 0x7
40:            
41:                while(!PIR2bits.CCP2IF);
01BF  0141     MOVLB 0x1
01C0  1D8E     BTFSS PIR2, 0x3
01C1  29C3     GOTO 0x1C3
01C2  29C4     GOTO 0x1C4
01C3  29BF     GOTO 0x1BF
42:                CCP2CONbits.EN = 0;
01C4  0147     MOVLB 0x7
01C5  1392     BCF CCP2CON, 0x7
43:                PIR2bits.CCP2IF = 0;
01C6  0141     MOVLB 0x1
01C7  118E     BCF PIR2, 0x3
44:                value3 = CCP2_CaptureRead();                                // Set value3 to be the current CCP2 value
01C8  318B     MOVLP 0xB
01C9  2344     CALL 0x344
01CA  3181     MOVLP 0x1
01CB  0871     MOVF 0xF1, W
01CC  0140     MOVLB 0x0
01CD  00A9     MOVWF 0x29
01CE  0870     MOVF __pcstackCOMMON, W
01CF  00A8     MOVWF value3
45:                CCP2CONbits.EN = 1;
01D0  0147     MOVLB 0x7
01D1  1792     BSF CCP2CON, 0x7
46:            
47:                while(!PIR2bits.CCP2IF);
01D2  0141     MOVLB 0x1
01D3  1D8E     BTFSS PIR2, 0x3
01D4  29D6     GOTO 0x1D6
01D5  29D7     GOTO 0x1D7
01D6  29D2     GOTO 0x1D2
48:                CCP2CONbits.EN = 0;
01D7  0147     MOVLB 0x7
01D8  1392     BCF CCP2CON, 0x7
49:                PIR2bits.CCP2IF = 0;
01D9  0141     MOVLB 0x1
01DA  118E     BCF PIR2, 0x3
50:                value4 = CCP2_CaptureRead();                                // Set value4 to be the current CCP2 value
01DB  318B     MOVLP 0xB
01DC  2344     CALL 0x344
01DD  3181     MOVLP 0x1
01DE  0871     MOVF 0xF1, W
01DF  0140     MOVLB 0x0
01E0  00A7     MOVWF 0x27
01E1  0870     MOVF __pcstackCOMMON, W
01E2  00A6     MOVWF value4
51:            
52:                while(!PIR2bits.CCP1IF);
01E3  0141     MOVLB 0x1
01E4  1D0E     BTFSS PIR2, 0x2
01E5  29E7     GOTO 0x1E7
01E6  29E8     GOTO 0x1E8
01E7  29E3     GOTO 0x1E3
53:            
54:                CCP1CONbits.EN = 0;
01E8  0147     MOVLB 0x7
01E9  138E     BCF CCP1CON, 0x7
55:                Timer1_Stop();                                              // Stop Timer1
01EA  318A     MOVLP 0xA
01EB  223D     CALL 0x23D
01EC  3181     MOVLP 0x1
56:            
57:                PIR2bits.CCP1IF = 0;
01ED  0141     MOVLB 0x1
01EE  110E     BCF PIR2, 0x2
58:            
59:                value2 = CCP1_CaptureRead();                                // Set value2 to be the current CCP1 value
01EF  318B     MOVLP 0xB
01F0  2336     CALL 0x336
01F1  3181     MOVLP 0x1
01F2  0871     MOVF 0xF1, W
01F3  0140     MOVLB 0x0
01F4  00AB     MOVWF 0x2B
01F5  0870     MOVF __pcstackCOMMON, W
01F6  00AA     MOVWF value2
60:            
61:                period_count = value2 - value1;                             // Calculate the period (difference between value2 and value1)
01F7  082C     MOVF value1, W
01F8  022A     SUBWF value2, W
01F9  00C6     MOVWF __pcstackBANK0
01FA  082D     MOVF 0x2D, W
01FB  3B2B     SUBWFB 0x2B, W
01FC  00C7     MOVWF 0x47
01FD  0846     MOVF __pcstackBANK0, W
01FE  00A0     MOVWF period_count
01FF  0847     MOVF 0x47, W
0200  00A1     MOVWF 0x21
0201  01A2     CLRF 0x22
62:                pulse_count = value4 - value3;                              // Calculate the pulse (difference between value4 and value3)
0202  0828     MOVF value3, W
0203  0226     SUBWF value4, W
0204  00C6     MOVWF __pcstackBANK0
0205  0829     MOVF 0x29, W
0206  3B27     SUBWFB 0x27, W
0207  00C7     MOVWF 0x47
0208  0846     MOVF __pcstackBANK0, W
0209  00A3     MOVWF pulse_count
020A  0847     MOVF 0x47, W
020B  00A4     MOVWF 0x24
020C  01A5     CLRF 0x25
63:                duty_cycle = (pulse_count << 8)/ (period_count >> 2);       // Calculate the duty cycle (pulse value right shifted 8 divided by the period left shifted 2)
020D  0820     MOVF period_count, W
020E  00C6     MOVWF __pcstackBANK0
020F  0821     MOVF 0x21, W
0210  00C7     MOVWF 0x47
0211  0822     MOVF 0x22, W
0212  00C8     MOVWF start
0213  3002     MOVLW 0x2
0214  36C8     LSRF start, F
0215  0CC7     RRF 0x47, F
0216  0CC6     RRF __pcstackBANK0, F
0217  0B89     DECFSZ WREG, F
0218  2A14     GOTO 0x214
0219  0846     MOVF __pcstackBANK0, W
021A  00F0     MOVWF __pcstackCOMMON
021B  0847     MOVF 0x47, W
021C  00F1     MOVWF str
021D  0848     MOVF start, W
021E  00F2     MOVWF number
021F  0823     MOVF pulse_count, W
0220  00C9     MOVWF TMR0_val
0221  0824     MOVF 0x24, W
0222  00CA     MOVWF period_countH
0223  0825     MOVF 0x25, W
0224  00CB     MOVWF period_countL
0225  3008     MOVLW 0x8
0226  35C9     LSLF TMR0_val, F
0227  0DCA     RLF period_countH, F
0228  0DCB     RLF period_countL, F
0229  0B89     DECFSZ WREG, F
022A  2A26     GOTO 0x226
022B  0849     MOVF TMR0_val, W
022C  00F3     MOVWF module
022D  084A     MOVF period_countH, W
022E  00F4     MOVWF pulse_countL
022F  084B     MOVF period_countL, W
0230  00F5     MOVWF period_countH
0231  318F     MOVLP 0xF
0232  27B4     CALL 0x7B4
0233  3181     MOVLP 0x1
0234  0870     MOVF __pcstackCOMMON, W
0235  0140     MOVLB 0x0
0236  00CC     MOVWF pulse_countH
0237  084C     MOVF pulse_countH, W
0238  00C4     MOVWF duty_cycle
64:            
65:                EUSART1_sendString("\nPULSE:");                             // Send pulse data over UART
0239  3050     MOVLW 0x50
023A  00F1     MOVWF str
023B  3091     MOVLW 0x91
023C  00F2     MOVWF number
023D  318E     MOVLP 0xE
023E  26B3     CALL 0x6B3
023F  3181     MOVLP 0x1
66:                EUSART1_sendInt(pulse_count>>16);
0240  0140     MOVLB 0x0
0241  0823     MOVF pulse_count, W
0242  00C6     MOVWF __pcstackBANK0
0243  0824     MOVF 0x24, W
0244  00C7     MOVWF 0x47
0245  0825     MOVF 0x25, W
0246  00C8     MOVWF start
0247  3010     MOVLW 0x10
0248  36C8     LSRF start, F
0249  0CC7     RRF 0x47, F
024A  0CC6     RRF __pcstackBANK0, F
024B  0B89     DECFSZ WREG, F
024C  2A48     GOTO 0x248
024D  0846     MOVF __pcstackBANK0, W
024E  318B     MOVLP 0xB
024F  2390     CALL 0x390
0250  3181     MOVLP 0x1
67:                EUSART1_sendInt(pulse_count>>8);
0251  0140     MOVLB 0x0
0252  0823     MOVF pulse_count, W
0253  00C6     MOVWF __pcstackBANK0
0254  0824     MOVF 0x24, W
0255  00C7     MOVWF 0x47
0256  0825     MOVF 0x25, W
0257  00C8     MOVWF start
0258  3008     MOVLW 0x8
0259  36C8     LSRF start, F
025A  0CC7     RRF 0x47, F
025B  0CC6     RRF __pcstackBANK0, F
025C  0B89     DECFSZ WREG, F
025D  2A59     GOTO 0x259
025E  0846     MOVF __pcstackBANK0, W
025F  318B     MOVLP 0xB
0260  2390     CALL 0x390
0261  3181     MOVLP 0x1
68:                EUSART1_sendInt(pulse_count);
0262  0140     MOVLB 0x0
0263  0823     MOVF pulse_count, W
0264  318B     MOVLP 0xB
0265  2390     CALL 0x390
0266  3181     MOVLP 0x1
69:            
70:                EUSART1_sendString("\nPD: ");                               // Send period data over UART
0267  305E     MOVLW 0x5E
0268  00F1     MOVWF str
0269  3091     MOVLW 0x91
026A  00F2     MOVWF number
026B  318E     MOVLP 0xE
026C  26B3     CALL 0x6B3
026D  3181     MOVLP 0x1
71:                EUSART1_sendInt(period_count>>8);
026E  0140     MOVLB 0x0
026F  0820     MOVF period_count, W
0270  00C6     MOVWF __pcstackBANK0
0271  0821     MOVF 0x21, W
0272  00C7     MOVWF 0x47
0273  0822     MOVF 0x22, W
0274  00C8     MOVWF start
0275  3008     MOVLW 0x8
0276  36C8     LSRF start, F
0277  0CC7     RRF 0x47, F
0278  0CC6     RRF __pcstackBANK0, F
0279  0B89     DECFSZ WREG, F
027A  2A76     GOTO 0x276
027B  0846     MOVF __pcstackBANK0, W
027C  318B     MOVLP 0xB
027D  2390     CALL 0x390
027E  3181     MOVLP 0x1
72:                EUSART1_sendInt(period_count);
027F  0140     MOVLB 0x0
0280  0820     MOVF period_count, W
0281  318B     MOVLP 0xB
0282  2390     CALL 0x390
0283  3181     MOVLP 0x1
73:            
74:                EUSART1_sendString("\nDC: ");                               // Send duty cycle data over UART
0284  3058     MOVLW 0x58
0285  00F1     MOVWF str
0286  3091     MOVLW 0x91
0287  00F2     MOVWF number
0288  318E     MOVLP 0xE
0289  26B3     CALL 0x6B3
028A  3181     MOVLP 0x1
75:                EUSART1_sendInt(duty_cycle);
028B  0140     MOVLB 0x0
028C  0844     MOVF duty_cycle, W
028D  318B     MOVLP 0xB
028E  2390     CALL 0x390
028F  3181     MOVLP 0x1
76:            
77:                pulse_count = 0;
0290  3000     MOVLW 0x0
0291  0140     MOVLB 0x0
0292  00A3     MOVWF pulse_count
0293  3000     MOVLW 0x0
0294  00A4     MOVWF 0x24
0295  3000     MOVLW 0x0
0296  00A5     MOVWF 0x25
78:                period_count = 0;
0297  3000     MOVLW 0x0
0298  00A0     MOVWF period_count
0299  3000     MOVLW 0x0
029A  00A1     MOVWF 0x21
029B  3000     MOVLW 0x0
029C  00A2     MOVWF 0x22
79:            
80:                __delay_ms(1);                                              // Wait for 1ms
029D  3006     MOVLW 0x6
029E  0140     MOVLB 0x0
029F  00C6     MOVWF __pcstackBANK0
02A0  3030     MOVLW 0x30
02A1  0B89     DECFSZ WREG, F
02A2  2AA1     GOTO 0x2A1
02A3  0BC6     DECFSZ __pcstackBANK0, F
02A4  2AA1     GOTO 0x2A1
02A5  0000     NOP
81:            }
02A6  0008     RETURN
---  C:/CodeExamples/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody/pic16f18076-calculating-pulse-and-duty-cycle-mplab-melody.X/Basic_Init.c
1:             /*
2:              * File:   Basic_Init.c
3:              * Author: C63290
4:              *
5:              * Created on November 15, 2022, 10:31 AM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "Basic_Init.h"
11:            #include "CLC_NCO.h"
12:            #include "mcc_generated_files/system/system.h"
13:            
14:            // Peripheral Functions and Declarations   
15:                
16:                //Timer 0 Functions and Declarations
17:            
18:            volatile uint16_t timerTMR0ReloadVal16bit;
19:            
20:            const struct TMR_INTERFACE Timer0 = {
21:                .Initialize = Timer0_Initialize,
22:                .Start = Timer0_Start,
23:                .Stop = Timer0_Stop,
24:                .PeriodCountSet = Timer0_Write,
25:                .TimeoutCallbackRegister = Timer0_OverflowCallbackRegister
26:            };
27:            
28:            static void (*Timer0_OverflowCallback)(void);
29:            static void Timer0_DefaultOverflowCallback(void);
30:            
31:            void Timer0_Initialize(void){
32:                //TMR0H 255; 
33:                TMR0H = 0xFF;
0D29  30FF     MOVLW 0xFF
0D2A  0143     MOVLB 0x3
0D2B  009D     MOVWF TMR0H
34:            
35:                //TMR0L 240; 
36:                TMR0L = 0xF0;
0D2C  30F0     MOVLW 0xF0
0D2D  009C     MOVWF TMR0L
37:            
38:                //T0CS HFINTOSC; T0CKPS 1:1; T0ASYNC not_synchronised; 
39:                T0CON1 = 0x70;
0D2E  3070     MOVLW 0x70
0D2F  009F     MOVWF T0CON1
40:            
41:                //Load TMRTMR0 value to the 16-bit reload variable
42:                timerTMR0ReloadVal16bit = ((uint16_t)TMR0H << 8) | TMR0L;
0D30  081D     MOVF TMR0H, W
0D31  0140     MOVLB 0x0
0D32  00B9     MOVWF 0x39
0D33  0143     MOVLB 0x3
0D34  081C     MOVF TMR0L, W
0D35  0140     MOVLB 0x0
0D36  00B8     MOVWF timerTMR0ReloadVal16bit
43:            
44:                //Set default callback for TMR0 overflow interrupt
45:                Timer0_OverflowCallbackRegister(Timer0_DefaultOverflowCallback);
0D37  3000     MOVLW 0x0
0D38  00F0     MOVWF __pcstackCOMMON
0D39  3000     MOVLW 0x0
0D3A  00F1     MOVWF str
0D3B  318A     MOVLP 0xA
0D3C  227C     CALL 0x27C
0D3D  318D     MOVLP 0xD
46:            
47:                //Clear interrupt flag
48:                PIR0bits.TMR0IF = 0;
0D3E  0141     MOVLB 0x1
0D3F  128C     BCF PIR0, 0x5
49:            
50:                //T0OUTPS 1:1; T0EN disabled; T016BIT 16-bit; 
51:                T0CON0 = 0x10;
0D40  3010     MOVLW 0x10
0D41  0143     MOVLB 0x3
0D42  009E     MOVWF T0CON0
52:            }
0D43  0008     RETURN
53:            void Timer0_Start(void){
54:                T0CON0bits.T0EN = 1;
0A43  0143     MOVLB 0x3
0A44  179E     BSF T0CON0, 0x7
55:            }
0A45  0008     RETURN
56:            void Timer0_Stop(void){
57:                T0CON0bits.T0EN = 0;
0A40  0143     MOVLB 0x3
0A41  139E     BCF T0CON0, 0x7
58:            }
0A42  0008     RETURN
59:            uint16_t Timer0_Read(void){
60:                uint16_t readVal;
61:                uint8_t readValLow;
62:                uint8_t readValHigh;
63:            
64:                readValLow  = TMR0L;
0D99  0143     MOVLB 0x3
0D9A  081C     MOVF TMR0L, W
0D9B  00F2     MOVWF 0x1F2
0D9C  0872     MOVF 0x1F2, W
0D9D  00F9     MOVWF 0x1F9
65:                readValHigh = TMR0H;
0D9E  081D     MOVF TMR0H, W
0D9F  00F2     MOVWF 0x1F2
0DA0  0872     MOVF 0x1F2, W
0DA1  00FA     MOVWF 0x1FA
66:                readVal  = ((uint16_t)readValHigh << 8) + readValLow;
0DA2  0879     MOVF 0x1F9, W
0DA3  00F2     MOVWF 0x1F2
0DA4  01F3     CLRF 0x1F3
0DA5  087A     MOVF 0x1FA, W
0DA6  00F4     MOVWF 0x1F4
0DA7  01F5     CLRF 0x1F5
0DA8  0874     MOVF 0x1F4, W
0DA9  00F5     MOVWF 0x1F5
0DAA  01F4     CLRF 0x1F4
0DAB  0872     MOVF 0x1F2, W
0DAC  0774     ADDWF 0x1F4, W
0DAD  00F7     MOVWF 0x1F7
0DAE  0873     MOVF 0x1F3, W
0DAF  3D75     ADDWFC 0x1F5, W
0DB0  00F8     MOVWF 0x1F8
67:            
68:                return readVal;
0DB1  0878     MOVF 0x1F8, W
0DB2  00F1     MOVWF 0x1F1
0DB3  0877     MOVF 0x1F7, W
0DB4  00F0     MOVWF 0x1F0
69:            }
0DB5  0008     RETURN
70:            void Timer0_Write(size_t timerVal){
71:                TMR0H = timerVal >> 8;
72:                TMR0L = (uint8_t) timerVal;
73:            }
74:            void Timer0_OverflowCallbackRegister(void (* CallbackHandler)(void)){
75:                Timer0_OverflowCallback = CallbackHandler;
0A7C  0871     MOVF 0x1F1, W
0A7D  0140     MOVLB 0x0
0A7E  00B7     MOVWF 0x37
0A7F  0870     MOVF __pcstackCOMMON, W
0A80  00B6     MOVWF Timer0_OverflowCallback
76:            }
0A81  0008     RETURN
77:            static void Timer0_DefaultOverflowCallback(void){
78:                //Add your interrupt code here or
79:                //Use Timer0_OverflowCallbackRegister function to use Custom ISR
80:            }
81:            void Timer0_Initialize_CLCNCO3(void){
82:                //TMR0H 255; 
83:                TMR0H = 0xFF;
0BB3  30FF     MOVLW 0xFF
0BB4  0143     MOVLB 0x3
0BB5  009D     MOVWF TMR0H
84:            
85:                //TMR0L 0; 
86:                TMR0L = 0x0;
0BB6  019C     CLRF TMR0L
87:            
88:                //T0CS CLC1_OUT; T0CKPS 1:1; T0ASYNC synchronised; 
89:                T0CON1 = 0xE0;
0BB7  30E0     MOVLW 0xE0
0BB8  009F     MOVWF T0CON1
90:            
91:                //Set default callback for TMR0 overflow interrupt
92:                Timer0_OverflowCallbackRegister(Timer0_DefaultOverflowCallback);
0BB9  3000     MOVLW 0x0
0BBA  00F0     MOVWF 0x1F0
0BBB  3000     MOVLW 0x0
0BBC  00F1     MOVWF 0x1F1
0BBD  318A     MOVLP 0xA
0BBE  227C     CALL 0x27C
0BBF  318B     MOVLP 0xB
93:            
94:                //Clear interrupt flag
95:                PIR0bits.TMR0IF = 0;
0BC0  0141     MOVLB 0x1
0BC1  128C     BCF PIR0, 0x5
96:            
97:                //T0OUTPS 1:1; T0EN disabled; T016BIT 8-bit; 
98:                T0CON0 = 0x0;
0BC2  0143     MOVLB 0x3
0BC3  019E     CLRF T0CON0
99:            }
0BC4  0008     RETURN
100:           
101:               //Timer 1 Functions and Declarations
102:           
103:           volatile uint16_t timer1ReloadVal;
104:           
105:           const struct TMR_INTERFACE Timer1 = {
106:               .Initialize = Timer1_Initialize,
107:               .Start = Timer1_Start,
108:               .Stop = Timer1_Stop,
109:               .PeriodCountSet = Timer1_Write,
110:               .TimeoutCallbackRegister = Timer1_OverflowCallbackRegister,
111:               .Tasks = NULL
112:           };
113:           
114:           static void (*Timer1_OverflowCallback)(void);
115:           static void Timer1_DefaultOverflowCallback(void);
116:           
117:           void Timer1_StartSinglePulseAcquisition(void){
118:               T1GCONbits.T1GGO = 1;
0A46  0145     MOVLB 0x5
0A47  158F     BSF T1GCON, 0x3
119:           }
0A48  0008     RETURN
120:           void Timer1_Start(void){
121:               // Start the Timer by writing to TMRxON bit
122:               T1CONbits.TMR1ON = 1;
0A3A  0145     MOVLB 0x5
0A3B  140E     BSF T1CON, 0x0
123:           }
0A3C  0008     RETURN
124:           void Timer1_Write(size_t timerVal){
125:               if (T1CONbits.nT1SYNC == 1)
126:               {
127:                   // Stop the Timer by writing to TMRxON bit
128:                   T1CONbits.TMR1ON = 0;
129:           
130:                   // Write to the Timer1 register
131:                   TMR1H = (uint8_t)(timerVal >> 8);
132:                   TMR1L = (uint8_t)timerVal;
133:           
134:                   // Start the Timer after writing to the register
135:                   T1CONbits.TMR1ON = 1;
136:               }
137:               else
138:               {
139:                   // Write to the Timer1 register
140:                   TMR1H = (uint8_t)(timerVal >> 8);
141:                   TMR1L = (uint8_t)timerVal;
142:               }
143:           }
144:           void Timer1_Stop(void){
145:               // Stop the Timer by writing to TMRxON bit
146:               T1CONbits.TMR1ON = 0;
0A3D  0145     MOVLB 0x5
0A3E  100E     BCF T1CON, 0x0
147:           }
0A3F  0008     RETURN
148:           void Timer1_OverflowCallbackRegister(void (* CallbackHandler)(void)){
149:               Timer1_OverflowCallback = CallbackHandler;
0A70  0871     MOVF 0x2F1, W
0A71  0140     MOVLB 0x0
0A72  00B3     MOVWF 0x33
0A73  0870     MOVF __pcstackCOMMON, W
0A74  00B2     MOVWF Timer1_OverflowCallback
150:           }
0A75  0008     RETURN
151:           static void Timer1_DefaultOverflowCallback(void){
152:               //Add your interrupt code here or
153:               //Use Timer1_OverflowCallbackRegister function to use Custom ISR
154:           }
155:           void Timer1_Initialize_Timer1Gate(void){
156:               //TGGO done; TGSPM enabled; TGTM disabled; TGPOL low; TMRGE disabled; 
157:               T1GCON = 0x10;
0E31  3010     MOVLW 0x10
0E32  0145     MOVLB 0x5
0E33  008F     MOVWF T1GCON
158:               //TGSS T1GPPS; 
159:               T1GATE = 0x0;
0E34  0190     CLRF T1GATE
160:               //TMRCS FOSC; 
161:               T1CLK = 0x2;
0E35  3002     MOVLW 0x2
0E36  0091     MOVWF T1CLK
162:               //TMRH 255; 
163:               TMR1H = 0xFF;
0E37  30FF     MOVLW 0xFF
0E38  008D     MOVWF TMR1H
164:               //TMRL 156; 
165:               TMR1L = 0x9C;
0E39  309C     MOVLW 0x9C
0E3A  008C     MOVWF TMR1
166:           
167:               // Load the TMR1 value to reload variable
168:               timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
0E3B  080D     MOVF TMR1H, W
0E3C  0140     MOVLB 0x0
0E3D  00B5     MOVWF 0x35
0E3E  0145     MOVLB 0x5
0E3F  080C     MOVF TMR1, W
0E40  0140     MOVLB 0x0
0E41  00B4     MOVWF timer1ReloadVal
169:           
170:               //Set default callback for TMR1 overflow interrupt
171:               Timer1_OverflowCallbackRegister(Timer1_DefaultOverflowCallback);
0E42  3000     MOVLW 0x0
0E43  00F0     MOVWF __pcstackCOMMON
0E44  3000     MOVLW 0x0
0E45  00F1     MOVWF str
0E46  318A     MOVLP 0xA
0E47  2270     CALL 0x270
0E48  318E     MOVLP 0xE
172:           
173:                   // Clearing TMRGI IF flag before enabling the interrupt.
174:                    PIR1bits.TMR1GIF = 0;
0E49  0141     MOVLB 0x1
0E4A  120D     BCF PIR1, 0x4
175:                   // Enabling TMRGI interrupt.
176:                    PIE1bits.TMR1GIE = 0;
0E4B  1217     BCF PIE1, 0x4
177:           
178:               
179:               //TMRON enabled; TRD16 disabled; nTSYNC synchronize; TCKPS 1:1; 
180:               T1CON = 0x1;
0E4C  3001     MOVLW 0x1
0E4D  0145     MOVLB 0x5
0E4E  008E     MOVWF T1CON
181:           }
0E4F  0008     RETURN
182:           void Timer1_Initialize_CLCNCO1(void){
183:               //TGGO done; TGSPM disabled; TGTM disabled; TGPOL low; TMRGE disabled; 
184:               T1GCON = 0x0;
0D44  0145     MOVLB 0x5
0D45  018F     CLRF T1GCON
185:               //TGSS T1GPPS; 
186:               T1GATE = 0x0;
0D46  0190     CLRF T1GATE
187:               //TMRCS FOSC; 
188:               T1CLK = 0x2;
0D47  3002     MOVLW 0x2
0D48  0091     MOVWF T1CLK
189:               //TMRH 0; 
190:               TMR1H = 0x0;
0D49  018D     CLRF TMR1H
191:               //TMRL 1; 
192:               TMR1L = 0x1;
0D4A  3001     MOVLW 0x1
0D4B  008C     MOVWF TMR1
193:           
194:               // Load the TMR1 value to reload variable
195:               timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
0D4C  080D     MOVF TMR1H, W
0D4D  0140     MOVLB 0x0
0D4E  00B5     MOVWF 0x35
0D4F  0145     MOVLB 0x5
0D50  080C     MOVF TMR1, W
0D51  0140     MOVLB 0x0
0D52  00B4     MOVWF timer1ReloadVal
196:           
197:               //Set default callback for TMR1 overflow interrupt
198:               Timer1_OverflowCallbackRegister(Timer1_DefaultOverflowCallback);
0D53  3000     MOVLW 0x0
0D54  00F0     MOVWF __pcstackCOMMON
0D55  3000     MOVLW 0x0
0D56  00F1     MOVWF str
0D57  318A     MOVLP 0xA
0D58  2270     CALL 0x270
0D59  318D     MOVLP 0xD
199:           
200:               //Clear interrupt flags
201:               PIR1bits.TMR1IF = 0;
0D5A  0141     MOVLB 0x1
0D5B  118D     BCF PIR1, 0x3
202:               PIR1bits.TMR1GIF = 0;
0D5C  120D     BCF PIR1, 0x4
203:               
204:               //TMRON disabled; TRD16 disabled; nTSYNC synchronize; TCKPS 1:1; 
205:               T1CON = 0x0;
0D5D  0145     MOVLB 0x5
0D5E  018E     CLRF T1CON
206:           }
0D5F  0008     RETURN
207:           void Timer1_Initialize_CLCNCO2(void){
208:               //TGGO done; TGSPM disabled; TGTM disabled; TGPOL low; TMRGE disabled; 
209:               T1GCON = 0x0;
0CD8  0145     MOVLB 0x5
0CD9  018F     CLRF T1GCON
210:               //TGSS T1GPPS; 
211:               T1GATE = 0x0;
0CDA  0190     CLRF T1GATE
212:               //TMRCS FOSC; 
213:               T1CLK = 0x2;
0CDB  3002     MOVLW 0x2
0CDC  0091     MOVWF T1CLK
214:               //TMRH 0; 
215:               TMR1H = 0x0;
0CDD  018D     CLRF TMR1H
216:               //TMRL 1; 
217:               TMR1L = 0x0;
0CDE  018C     CLRF TMR1
218:           
219:               // Load the TMR1 value to reload variable
220:               timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
0CDF  080D     MOVF TMR1H, W
0CE0  0140     MOVLB 0x0
0CE1  00B5     MOVWF 0x35
0CE2  0145     MOVLB 0x5
0CE3  080C     MOVF TMR1, W
0CE4  0140     MOVLB 0x0
0CE5  00B4     MOVWF timer1ReloadVal
221:           
222:               //Set default callback for TMR1 overflow interrupt
223:               Timer1_OverflowCallbackRegister(Timer1_DefaultOverflowCallback);
0CE6  3000     MOVLW 0x0
0CE7  00F0     MOVWF __pcstackCOMMON
0CE8  3000     MOVLW 0x0
0CE9  00F1     MOVWF str
0CEA  318A     MOVLP 0xA
0CEB  2270     CALL 0x270
0CEC  318C     MOVLP 0xC
224:           
225:               //Clear interrupt flags
226:               PIR1bits.TMR1IF = 0;
0CED  0141     MOVLB 0x1
0CEE  118D     BCF PIR1, 0x3
227:               PIR1bits.TMR1GIF = 0;
0CEF  120D     BCF PIR1, 0x4
228:               
229:               //TMRON disabled; TRD16 disabled; nTSYNC synchronize; TCKPS 1:1; 
230:               T1CON = 0x0;
0CF0  0145     MOVLB 0x5
0CF1  018E     CLRF T1CON
231:           }
0CF2  0008     RETURN
232:           void Timer1_Initialize_CLCNCO3(void){
233:               //TGGO done; TGSPM disabled; TGTM disabled; TGPOL low; TMRGE disabled; 
234:               T1GCON = 0x0;
0CF3  0145     MOVLB 0x5
0CF4  018F     CLRF T1GCON
235:               //TGSS T1GPPS; 
236:               T1GATE = 0x0;
0CF5  0190     CLRF T1GATE
237:               //TMRCS FOSC; 
238:               T1CLK = 0x2;
0CF6  3002     MOVLW 0x2
0CF7  0091     MOVWF T1CLK
239:               //TMRH 0; 
240:               TMR1H = 0x0;
0CF8  018D     CLRF TMR1H
241:               //TMRL 1; 
242:               TMR1L = 0x0;
0CF9  018C     CLRF TMR1
243:           
244:               // Load the TMR1 value to reload variable
245:               timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
0CFA  080D     MOVF TMR1H, W
0CFB  0140     MOVLB 0x0
0CFC  00B5     MOVWF 0x35
0CFD  0145     MOVLB 0x5
0CFE  080C     MOVF TMR1, W
0CFF  0140     MOVLB 0x0
0D00  00B4     MOVWF timer1ReloadVal
246:           
247:               //Set default callback for TMR1 overflow interrupt
248:               Timer1_OverflowCallbackRegister(Timer1_DefaultOverflowCallback);
0D01  3000     MOVLW 0x0
0D02  00F0     MOVWF __pcstackCOMMON
0D03  3000     MOVLW 0x0
0D04  00F1     MOVWF str
0D05  318A     MOVLP 0xA
0D06  2270     CALL 0x270
0D07  318C     MOVLP 0xC
249:           
250:               //Clear interrupt flags
251:               PIR1bits.TMR1IF = 0;
0D08  0141     MOVLB 0x1
0D09  118D     BCF PIR1, 0x3
252:               PIR1bits.TMR1GIF = 0;
0D0A  120D     BCF PIR1, 0x4
253:               
254:               //TMRON disabled; TRD16 disabled; nTSYNC synchronize; TCKPS 1:1; 
255:               T1CON = 0x0;
0D0B  0145     MOVLB 0x5
0D0C  018E     CLRF T1CON
256:           }
0D0D  0008     RETURN
257:           void Timer1_Initialize(void){
258:               //TGGO done; TGSPM disabled; TGTM disabled; TGPOL low; TMRGE disabled; 
259:               T1GCON = 0x0;
260:               //TGSS T1GPPS; 
261:               T1GATE = 0x0;
262:               //TMRCS FOSC; 
263:               T1CLK = 0x2;
264:               //TMRH 0; 
265:               TMR1H = 0x0;
266:               //TMRL 1; 
267:               TMR1L = 0x1;
268:           };
269:           
270:               //CLC1 Functions and Declarations
271:           
272:           static void (*CLC1_CLCI_InterruptHandler)(void);
273:           static void CLC1_DefaultCLCI_ISR(void);
274:           
275:           void CLC1_Initialize(void){
276:               
277:               // SLCT 0x0; 
278:               CLCSELECT = 0x0;
279:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
280:               CLCnPOL = 0x9;
281:               // LCD1S CLCIN2 (CLCIN2PPS); 
282:               CLCnSEL0 = 0x2;
283:               // LCD2S CLCIN0 (CLCIN0PPS); 
284:               CLCnSEL1 = 0x0;
285:               // LCD3S FOSC; 
286:               CLCnSEL2 = 0x4;
287:               // LCD4S CLC2_OUT; 
288:               CLCnSEL3 = 0x1D;
289:               // LCG1D1N disabled; LCG1D1T disabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
290:               CLCnGLS0 = 0x0;
291:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
292:               CLCnGLS1 = 0x8;
293:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T enabled; LCG3D4N disabled; LCG3D4T disabled; 
294:               CLCnGLS2 = 0x20;
295:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T enabled; 
296:               CLCnGLS3 = 0x80;
297:               // LCOUT 0x00; 
298:               CLCDATA = 0x0;
299:               // LCMODE 4-input AND; LCINTN enabled; LCINTP disabled; LCEN enabled; 
300:               CLCnCON = 0x8A;
301:           
302:               // Clear the CLC interrupt flag
303:               PIR2bits.CLC1IF = 0;
304:               //Configure interrupt handlers
305:               CLC1_CLCI_SetInterruptHandler(CLC1_DefaultCLCI_ISR);
306:               // Enabling CLC1 interrupt.
307:               PIE2bits.CLC1IE = 0;
308:           }
309:           void CLC1_Initialize_CLCNCO1(void){
310:               
311:               // SLCT 0x0; 
312:               CLCSELECT = 0x0;
0E50  014B     MOVLB 0xB
0E51  0196     CLRF CLCSELECT
313:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
314:               CLCnPOL = 0x9;
0E52  3009     MOVLW 0x9
0E53  008D     MOVWF CLCnPOL
315:               // LCD1S CLCIN2 (CLCIN2PPS); 
316:               CLCnSEL0 = 0x2;
0E54  3002     MOVLW 0x2
0E55  008E     MOVWF CLCnSEL0
317:               // LCD2S CLCIN0 (CLCIN0PPS); 
318:               CLCnSEL1 = 0x0;
0E56  018F     CLRF CLCnSEL1
319:               // LCD3S FOSC; 
320:               CLCnSEL2 = 0x4;
0E57  3004     MOVLW 0x4
0E58  0090     MOVWF CLCnSEL2
321:               // LCD4S CLC2_OUT; 
322:               CLCnSEL3 = 0x1D;
0E59  301D     MOVLW 0x1D
0E5A  0091     MOVWF CLCnSEL3
323:               // LCG1D1N disabled; LCG1D1T disabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
324:               CLCnGLS0 = 0x0;
0E5B  0192     CLRF CLCnGLS0
325:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
326:               CLCnGLS1 = 0x8;
0E5C  3008     MOVLW 0x8
0E5D  0093     MOVWF CLCnGLS1
327:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T enabled; LCG3D4N disabled; LCG3D4T disabled; 
328:               CLCnGLS2 = 0x20;
0E5E  3020     MOVLW 0x20
0E5F  0094     MOVWF CLCnGLS2
329:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T enabled; 
330:               CLCnGLS3 = 0x80;
0E60  3080     MOVLW 0x80
0E61  0095     MOVWF CLCnGLS3
331:               // LCOUT 0x00; 
332:               CLCDATA = 0x0;
0E62  0197     CLRF CLCDATA
333:               // LCMODE 4-input AND; LCINTN enabled; LCINTP disabled; LCEN enabled; 
334:               CLCnCON = 0x8A;
0E63  308A     MOVLW 0x8A
0E64  008C     MOVWF CLCnCON
335:           
336:               // Clear the CLC interrupt flag
337:               PIR2bits.CLC1IF = 0;
0E65  0141     MOVLB 0x1
0E66  130E     BCF PIR2, 0x6
338:               //Configure interrupt handlers
339:               CLC1_CLCI_SetInterruptHandler(CLC1_DefaultCLCI_ISR);
0E67  3000     MOVLW 0x0
0E68  00F0     MOVWF 0xF0
0E69  3000     MOVLW 0x0
0E6A  00F1     MOVWF 0xF1
0E6B  318A     MOVLP 0xA
0E6C  226A     CALL 0x26A
0E6D  318E     MOVLP 0xE
340:               // Enabling CLC1 interrupt.
341:               PIE2bits.CLC1IE = 0;
0E6E  0141     MOVLB 0x1
0E6F  1318     BCF PIE2, 0x6
342:           }
0E70  0008     RETURN
343:           void CLC1_Initialize_CLCNCO2(void){
344:               
345:               // SLCT 0x0; 
346:               CLCSELECT = 0x0;
0E71  014B     MOVLB 0xB
0E72  0196     CLRF CLCSELECT
347:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
348:               CLCnPOL = 0x9;
0E73  3009     MOVLW 0x9
0E74  008D     MOVWF CLCnPOL
349:               // LCD1S CLCIN0 (CLCIN0PPS); 
350:               CLCnSEL0 = 0x0;
0E75  018E     CLRF CLCnSEL0
351:               // LCD2S FOSC; 
352:               CLCnSEL1 = 0x4;
0E76  3004     MOVLW 0x4
0E77  008F     MOVWF CLCnSEL1
353:               // LCD3S CLC2_OUT; 
354:               CLCnSEL2 = 0x1D;
0E78  301D     MOVLW 0x1D
0E79  0090     MOVWF CLCnSEL2
355:               // LCD4S CLC3_OUT; 
356:               CLCnSEL3 = 0x1E;
0E7A  301E     MOVLW 0x1E
0E7B  0091     MOVWF CLCnSEL3
357:               // LCG1D1N disabled; LCG1D1T disabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
358:               CLCnGLS0 = 0x0;
0E7C  0192     CLRF CLCnGLS0
359:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
360:               CLCnGLS1 = 0x8;
0E7D  3008     MOVLW 0x8
0E7E  0093     MOVWF CLCnGLS1
361:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T enabled; LCG3D4N disabled; LCG3D4T disabled; 
362:               CLCnGLS2 = 0x20;
0E7F  3020     MOVLW 0x20
0E80  0094     MOVWF CLCnGLS2
363:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T enabled; 
364:               CLCnGLS3 = 0x80;
0E81  3080     MOVLW 0x80
0E82  0095     MOVWF CLCnGLS3
365:               // LCOUT 0x00; 
366:               CLCDATA = 0x0;
0E83  0197     CLRF CLCDATA
367:               // LCMODE 4-input AND; LCINTN disabled; LCINTP disabled; LCEN enabled; 
368:               CLCnCON = 0x82;
0E84  3082     MOVLW 0x82
0E85  008C     MOVWF CLCnCON
369:           
370:               // Clear the CLC interrupt flag
371:               PIR2bits.CLC1IF = 0;
0E86  0141     MOVLB 0x1
0E87  130E     BCF PIR2, 0x6
372:               //Configure interrupt handlers
373:               CLC1_CLCI_SetInterruptHandler(CLC1_DefaultCLCI_ISR);
0E88  3000     MOVLW 0x0
0E89  00F0     MOVWF 0xF0
0E8A  3000     MOVLW 0x0
0E8B  00F1     MOVWF 0xF1
0E8C  318A     MOVLP 0xA
0E8D  226A     CALL 0x26A
0E8E  318E     MOVLP 0xE
374:               // Enabling CLC1 interrupt.
375:               PIE2bits.CLC1IE = 0;
0E8F  0141     MOVLB 0x1
0E90  1318     BCF PIE2, 0x6
376:           }
0E91  0008     RETURN
377:           void CLC1_Initialize_CLCNCO3(void){
378:               
379:               // SLCT 0x0; 
380:               CLCSELECT = 0x0;
0E92  014B     MOVLB 0xB
0E93  0196     CLRF CLCSELECT
381:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
382:               CLCnPOL = 0x9;
0E94  3009     MOVLW 0x9
0E95  008D     MOVWF CLCnPOL
383:               // LCD1S CLCIN0 (CLCIN0PPS); 
384:               CLCnSEL0 = 0x0;
0E96  018E     CLRF CLCnSEL0
385:               // LCD2S NCO1_OUT; 
386:               CLCnSEL1 = 0x18;
0E97  3018     MOVLW 0x18
0E98  008F     MOVWF CLCnSEL1
387:               // LCD3S CLC2_OUT; 
388:               CLCnSEL2 = 0x1D;
0E99  301D     MOVLW 0x1D
0E9A  0090     MOVWF CLCnSEL2
389:               // LCD4S CLC3_OUT; 
390:               CLCnSEL3 = 0x1E;
0E9B  301E     MOVLW 0x1E
0E9C  0091     MOVWF CLCnSEL3
391:               // LCG1D1N disabled; LCG1D1T disabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
392:               CLCnGLS0 = 0x0;
0E9D  0192     CLRF CLCnGLS0
393:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
394:               CLCnGLS1 = 0x8;
0E9E  3008     MOVLW 0x8
0E9F  0093     MOVWF CLCnGLS1
395:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T enabled; LCG3D4N disabled; LCG3D4T disabled; 
396:               CLCnGLS2 = 0x20;
0EA0  3020     MOVLW 0x20
0EA1  0094     MOVWF CLCnGLS2
397:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T enabled; 
398:               CLCnGLS3 = 0x80;
0EA2  3080     MOVLW 0x80
0EA3  0095     MOVWF CLCnGLS3
399:               // LCOUT 0x00; 
400:               CLCDATA = 0x0;
0EA4  0197     CLRF CLCDATA
401:               // LCMODE 4-input AND; LCINTN disabled; LCINTP disabled; LCEN enabled; 
402:               CLCnCON = 0x82;
0EA5  3082     MOVLW 0x82
0EA6  008C     MOVWF CLCnCON
403:           
404:               // Clear the CLC interrupt flag
405:               PIR2bits.CLC1IF = 0;
0EA7  0141     MOVLB 0x1
0EA8  130E     BCF PIR2, 0x6
406:               //Configure interrupt handlers
407:               CLC1_CLCI_SetInterruptHandler(CLC1_DefaultCLCI_ISR);
0EA9  3000     MOVLW 0x0
0EAA  00F0     MOVWF 0xF0
0EAB  3000     MOVLW 0x0
0EAC  00F1     MOVWF 0xF1
0EAD  318A     MOVLP 0xA
0EAE  226A     CALL 0x26A
0EAF  318E     MOVLP 0xE
408:               // Enabling CLC1 interrupt.
409:               PIE2bits.CLC1IE = 0;
0EB0  0141     MOVLB 0x1
0EB1  1318     BCF PIE2, 0x6
410:           }
0EB2  0008     RETURN
411:           void CLC1_CLCI_SetInterruptHandler(void (* InterruptHandler)(void)){
412:               CLC1_CLCI_InterruptHandler = InterruptHandler;
0A6A  0871     MOVF 0xF1, W
0A6B  0140     MOVLB 0x0
0A6C  00B1     MOVWF 0x31
0A6D  0870     MOVF __pcstackCOMMON, W
0A6E  00B0     MOVWF CLC1_CLCI_InterruptHandler
413:           }
0A6F  0008     RETURN
414:           static void CLC1_DefaultCLCI_ISR(void){
415:               //Add your interrupt code here or
416:               //Use CLC1_CLCI_SetInterruptHandler() function to use Custom ISR
417:           }
418:           
419:               //CLC2 Functions and Declarations
420:           
421:           void CLC2_Initialize(void){
422:               
423:               // SLCT 0x1; 
424:               CLCSELECT = 0x1;
425:               // LCG1POL not_inverted; LCG2POL inverted; LCG3POL not_inverted; LCG4POL not_inverted; LCPOL not_inverted; 
426:               CLCnPOL = 0x2;
427:               // LCD1S CLCIN0 (CLCIN0PPS); 
428:               CLCnSEL0 = 0x0;
429:               // LCD2S CLCIN2 (CLCIN2PPS); 
430:               CLCnSEL1 = 0x2;
431:               // LCD3S CLCIN1 (CLCIN1PPS); 
432:               CLCnSEL2 = 0x1;
433:               // LCD4S CLCIN0 (CLCIN0PPS); 
434:               CLCnSEL3 = 0x0;
435:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
436:               CLCnGLS0 = 0x2;
437:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T disabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
438:               CLCnGLS1 = 0x0;
439:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T enabled; LCG3D4N disabled; LCG3D4T disabled; 
440:               CLCnGLS2 = 0x20;
441:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
442:               CLCnGLS3 = 0x0;
443:               // LCOUT 0x00; 
444:               CLCDATA = 0x0;
445:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
446:               CLCnCON = 0x85;
447:           
448:           }
449:           void CLC2_Initialize_CLCNCO1(void){
450:               
451:               // SLCT 0x1; 
452:               CLCSELECT = 0x1;
0C24  3001     MOVLW 0x1
0C25  014B     MOVLB 0xB
0C26  0096     MOVWF CLCSELECT
453:               // LCG1POL not_inverted; LCG2POL inverted; LCG3POL not_inverted; LCG4POL not_inverted; LCPOL not_inverted; 
454:               CLCnPOL = 0x2;
0C27  3002     MOVLW 0x2
0C28  008D     MOVWF CLCnPOL
455:               // LCD1S CLCIN0 (CLCIN0PPS); 
456:               CLCnSEL0 = 0x0;
0C29  018E     CLRF CLCnSEL0
457:               // LCD2S CLCIN2 (CLCIN2PPS); 
458:               CLCnSEL1 = 0x2;
0C2A  3002     MOVLW 0x2
0C2B  008F     MOVWF CLCnSEL1
459:               // LCD3S CLCIN1 (CLCIN1PPS); 
460:               CLCnSEL2 = 0x1;
0C2C  3001     MOVLW 0x1
0C2D  0090     MOVWF CLCnSEL2
461:               // LCD4S CLCIN0 (CLCIN0PPS); 
462:               CLCnSEL3 = 0x0;
0C2E  0191     CLRF CLCnSEL3
463:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
464:               CLCnGLS0 = 0x2;
0C2F  3002     MOVLW 0x2
0C30  0092     MOVWF CLCnGLS0
465:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T disabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
466:               CLCnGLS1 = 0x0;
0C31  0193     CLRF CLCnGLS1
467:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T enabled; LCG3D4N disabled; LCG3D4T disabled; 
468:               CLCnGLS2 = 0x20;
0C32  3020     MOVLW 0x20
0C33  0094     MOVWF CLCnGLS2
469:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
470:               CLCnGLS3 = 0x0;
0C34  0195     CLRF CLCnGLS3
471:               // LCOUT 0x00; 
472:               CLCDATA = 0x0;
0C35  0197     CLRF CLCDATA
473:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
474:               CLCnCON = 0x85;
0C36  3085     MOVLW 0x85
0C37  008C     MOVWF CLCnCON
475:           
476:           }
0C38  0008     RETURN
477:           void CLC2_Initialize_CLCNCO2(void){
478:               
479:               // SLCT 0x1; 
480:               CLCSELECT = 0x1;
0BD8  3001     MOVLW 0x1
0BD9  014B     MOVLB 0xB
0BDA  0096     MOVWF CLCSELECT
481:               // LCG1POL not_inverted; LCG2POL inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
482:               CLCnPOL = 0xA;
0BDB  300A     MOVLW 0xA
0BDC  008D     MOVWF CLCnPOL
483:               // LCD1S CLCIN0 (CLCIN0PPS); 
484:               CLCnSEL0 = 0x0;
0BDD  018E     CLRF CLCnSEL0
485:               // LCD2S CLCIN0 (CLCIN0PPS); 
486:               CLCnSEL1 = 0x0;
0BDE  018F     CLRF CLCnSEL1
487:               // LCD3S CLCIN2 (CLCIN2PPS); 
488:               CLCnSEL2 = 0x2;
0BDF  3002     MOVLW 0x2
0BE0  0090     MOVWF CLCnSEL2
489:               // LCD4S CLCIN0 (CLCIN0PPS); 
490:               CLCnSEL3 = 0x0;
0BE1  0191     CLRF CLCnSEL3
491:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
492:               CLCnGLS0 = 0x2;
0BE2  3002     MOVLW 0x2
0BE3  0092     MOVWF CLCnGLS0
493:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T disabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
494:               CLCnGLS1 = 0x0;
0BE4  0193     CLRF CLCnGLS1
495:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T disabled; LCG3D4N disabled; LCG3D4T disabled; 
496:               CLCnGLS2 = 0x0;
0BE5  0194     CLRF CLCnGLS2
497:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
498:               CLCnGLS3 = 0x0;
0BE6  0195     CLRF CLCnGLS3
499:               // LCOUT 0x00; 
500:               CLCDATA = 0x0;
0BE7  0197     CLRF CLCDATA
501:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
502:               CLCnCON = 0x85;
0BE8  3085     MOVLW 0x85
0BE9  008C     MOVWF CLCnCON
503:           
504:           }
0BEA  0008     RETURN
505:           void CLC2_Initialize_CLCNCO3(void){
506:               
507:               // SLCT 0x1; 
508:               CLCSELECT = 0x1;
0BFE  3001     MOVLW 0x1
0BFF  014B     MOVLB 0xB
0C00  0096     MOVWF CLCSELECT
509:               // LCG1POL not_inverted; LCG2POL inverted; LCG3POL not_inverted; LCG4POL inverted; LCPOL not_inverted; 
510:               CLCnPOL = 0xA;
0C01  300A     MOVLW 0xA
0C02  008D     MOVWF CLCnPOL
511:               // LCD1S CLCIN0 (CLCIN0PPS); 
512:               CLCnSEL0 = 0x0;
0C03  018E     CLRF CLCnSEL0
513:               // LCD2S CLCIN0 (CLCIN0PPS); 
514:               CLCnSEL1 = 0x0;
0C04  018F     CLRF CLCnSEL1
515:               // LCD3S CLCIN2 (CLCIN2PPS); 
516:               CLCnSEL2 = 0x2;
0C05  3002     MOVLW 0x2
0C06  0090     MOVWF CLCnSEL2
517:               // LCD4S CLCIN0 (CLCIN0PPS); 
518:               CLCnSEL3 = 0x0;
0C07  0191     CLRF CLCnSEL3
519:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
520:               CLCnGLS0 = 0x2;
0C08  3002     MOVLW 0x2
0C09  0092     MOVWF CLCnGLS0
521:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T disabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
522:               CLCnGLS1 = 0x0;
0C0A  0193     CLRF CLCnGLS1
523:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T disabled; LCG3D4N disabled; LCG3D4T disabled; 
524:               CLCnGLS2 = 0x0;
0C0B  0194     CLRF CLCnGLS2
525:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
526:               CLCnGLS3 = 0x0;
0C0C  0195     CLRF CLCnGLS3
527:               // LCOUT 0x00; 
528:               CLCDATA = 0x0;
0C0D  0197     CLRF CLCDATA
529:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
530:               CLCnCON = 0x85;
0C0E  3085     MOVLW 0x85
0C0F  008C     MOVWF CLCnCON
531:           
532:           }
0C10  0008     RETURN
533:           
534:               //CLC3 Functions and Declarations
535:           
536:           void CLC3_Initialize(void){
537:               // SLCT 0x2; 
538:               CLCSELECT = 0x2;
539:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL not_inverted; LCPOL not_inverted; 
540:               CLCnPOL = 0x1;
541:               // LCD1S CLCIN0 (CLCIN0PPS); 
542:               CLCnSEL0 = 0x0;
543:               // LCD2S CLC2_OUT; 
544:               CLCnSEL1 = 0x1D;
545:               // LCD3S CLCIN3 (CLCIN3PPS); 
546:               CLCnSEL2 = 0x3;
547:               // LCD4S CLCIN0 (CLCIN0PPS); 
548:               CLCnSEL3 = 0x0;
549:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
550:               CLCnGLS0 = 0x2;
551:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
552:               CLCnGLS1 = 0x8;
553:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T disabled; LCG3D4N disabled; LCG3D4T disabled; 
554:               CLCnGLS2 = 0x0;
555:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
556:               CLCnGLS3 = 0x0;
557:               // LCOUT 0x00; 
558:               CLCDATA = 0x0;
559:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
560:               CLCnCON = 0x85;
561:           
562:           }
563:           void CLC3_Initialize_CLCNCO2(void){
564:               
565:               // SLCT 0x2; 
566:               CLCSELECT = 0x2;
0C4E  3002     MOVLW 0x2
0C4F  014B     MOVLB 0xB
0C50  0096     MOVWF CLCSELECT
567:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL not_inverted; LCPOL not_inverted; 
568:               CLCnPOL = 0x1;
0C51  3001     MOVLW 0x1
0C52  008D     MOVWF CLCnPOL
569:               // LCD1S CLCIN0 (CLCIN0PPS); 
570:               CLCnSEL0 = 0x0;
0C53  018E     CLRF CLCnSEL0
571:               // LCD2S CLC2_OUT; 
572:               CLCnSEL1 = 0x1D;
0C54  301D     MOVLW 0x1D
0C55  008F     MOVWF CLCnSEL1
573:               // LCD3S CLCIN3 (CLCIN3PPS); 
574:               CLCnSEL2 = 0x3;
0C56  3003     MOVLW 0x3
0C57  0090     MOVWF CLCnSEL2
575:               // LCD4S CLCIN0 (CLCIN0PPS); 
576:               CLCnSEL3 = 0x0;
0C58  0191     CLRF CLCnSEL3
577:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
578:               CLCnGLS0 = 0x2;
0C59  3002     MOVLW 0x2
0C5A  0092     MOVWF CLCnGLS0
579:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
580:               CLCnGLS1 = 0x8;
0C5B  3008     MOVLW 0x8
0C5C  0093     MOVWF CLCnGLS1
581:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T disabled; LCG3D4N disabled; LCG3D4T disabled; 
582:               CLCnGLS2 = 0x0;
0C5D  0194     CLRF CLCnGLS2
583:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
584:               CLCnGLS3 = 0x0;
0C5E  0195     CLRF CLCnGLS3
585:               // LCOUT 0x00; 
586:               CLCDATA = 0x0;
0C5F  0197     CLRF CLCDATA
587:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
588:               CLCnCON = 0x85;
0C60  3085     MOVLW 0x85
0C61  008C     MOVWF CLCnCON
589:           
590:           }
0C62  0008     RETURN
591:           void CLC3_Initialize_CLCNCO3(void){
592:               
593:               // SLCT 0x2; 
594:               CLCSELECT = 0x2;
0C63  3002     MOVLW 0x2
0C64  014B     MOVLB 0xB
0C65  0096     MOVWF CLCSELECT
595:               // LCG1POL inverted; LCG2POL not_inverted; LCG3POL not_inverted; LCG4POL not_inverted; LCPOL not_inverted; 
596:               CLCnPOL = 0x1;
0C66  3001     MOVLW 0x1
0C67  008D     MOVWF CLCnPOL
597:               // LCD1S CLCIN0 (CLCIN0PPS); 
598:               CLCnSEL0 = 0x0;
0C68  018E     CLRF CLCnSEL0
599:               // LCD2S CLC2_OUT; 
600:               CLCnSEL1 = 0x1D;
0C69  301D     MOVLW 0x1D
0C6A  008F     MOVWF CLCnSEL1
601:               // LCD3S CLCIN3 (CLCIN3PPS); 
602:               CLCnSEL2 = 0x3;
0C6B  3003     MOVLW 0x3
0C6C  0090     MOVWF CLCnSEL2
603:               // LCD4S CLCIN0 (CLCIN0PPS); 
604:               CLCnSEL3 = 0x0;
0C6D  0191     CLRF CLCnSEL3
605:               // LCG1D1N disabled; LCG1D1T enabled; LCG1D2N disabled; LCG1D2T disabled; LCG1D3N disabled; LCG1D3T disabled; LCG1D4N disabled; LCG1D4T disabled; 
606:               CLCnGLS0 = 0x2;
0C6E  3002     MOVLW 0x2
0C6F  0092     MOVWF CLCnGLS0
607:               // LCG2D1N disabled; LCG2D1T disabled; LCG2D2N disabled; LCG2D2T enabled; LCG2D3N disabled; LCG2D3T disabled; LCG2D4N disabled; LCG2D4T disabled; 
608:               CLCnGLS1 = 0x8;
0C70  3008     MOVLW 0x8
0C71  0093     MOVWF CLCnGLS1
609:               // LCG3D1N disabled; LCG3D1T disabled; LCG3D2N disabled; LCG3D2T disabled; LCG3D3N disabled; LCG3D3T disabled; LCG3D4N disabled; LCG3D4T disabled; 
610:               CLCnGLS2 = 0x0;
0C72  0194     CLRF CLCnGLS2
611:               // LCG4D1N disabled; LCG4D1T disabled; LCG4D2N disabled; LCG4D2T disabled; LCG4D3N disabled; LCG4D3T disabled; LCG4D4N disabled; LCG4D4T disabled; 
612:               CLCnGLS3 = 0x0;
0C73  0195     CLRF CLCnGLS3
613:               // LCOUT 0x00; 
614:               CLCDATA = 0x0;
0C74  0197     CLRF CLCDATA
615:               // LCMODE 2-input D flip-flop with R; LCINTN disabled; LCINTP disabled; LCEN enabled; 
616:               CLCnCON = 0x85;
0C75  3085     MOVLW 0x85
0C76  008C     MOVWF CLCnCON
617:           
618:           }
0C77  0008     RETURN
619:           
620:               //NCO1 Functions and Declarations
621:           
622:           
623:           void NCO1_Initialize_CLCNCO1_CLCNCO2(void){
624:               //NPWS 1_clk; NCKS CLC1_OUT; 
625:               NCO1CLK = 0xA;
0AF9  300A     MOVLW 0xA
0AFA  0149     MOVLB 0x9
0AFB  0093     MOVWF NCO1CLK
626:               //NCOACC 0x0; 
627:               NCO1ACCU = 0x0;
0AFC  018E     CLRF NCO1ACCU
628:               //NCOACC 0x0; 
629:               NCO1ACCH = 0x0;
0AFD  018D     CLRF NCO1ACCH
630:               //NCOACC 0x0; 
631:               NCO1ACCL = 0x0;
0AFE  018C     CLRF NCO1ACC
632:               //NCOINC 0; 
633:               NCO1INCU = 0x0;
0AFF  0191     CLRF NCO1INCU
634:               //NCOINC 0; 
635:               NCO1INCH = 0x0;
0B00  0190     CLRF NCO1INCH
636:               //NCOINC 1; 
637:               NCO1INCL = 0x1;
0B01  3001     MOVLW 0x1
0B02  008F     MOVWF NCO1INC
638:               //NEN disabled; NPOL active_hi; NPFM FDC_mode; 
639:               NCO1CON = 0x0;
0B03  0192     CLRF NCO1CON
640:           }
0B04  0008     RETURN
641:           void NCO1_Initialize_CLCNCO3(void){
642:               //NPWS 1_clk; NCKS FOSC; 
643:               NCO1CLK = 0x0;
0B29  0149     MOVLB 0x9
0B2A  0193     CLRF NCO1CLK
644:               //NCOACC 0x0; 
645:               NCO1ACCU = 0x0;
0B2B  018E     CLRF NCO1ACCU
646:               //NCOACC 0x0; 
647:               NCO1ACCH = 0x0;
0B2C  018D     CLRF NCO1ACCH
648:               //NCOACC 0x0; 
649:               NCO1ACCL = 0x0;
0B2D  018C     CLRF NCO1ACC
650:               //NCOINC 0; 
651:               NCO1INCU = 0x0;
0B2E  0191     CLRF NCO1INCU
652:               //NCOINC 130; 
653:               NCO1INCH = 0x82;
0B2F  3082     MOVLW 0x82
0B30  0090     MOVWF NCO1INCH
654:               //NCOINC 143; 
655:               NCO1INCL = 0x8F;
0B31  308F     MOVLW 0x8F
0B32  008F     MOVWF NCO1INC
656:               //NEN enabled; NPOL active_hi; NPFM FDC_mode; 
657:               NCO1CON = 0x80;
0B33  3080     MOVLW 0x80
0B34  0092     MOVWF NCO1CON
658:           }
0B35  0008     RETURN
659:           
660:               //CCP1 Functions and Declarations
661:           void CCP1_Initialize(void) {
662:               // Set the CCP1 to the options selected in the User Interface
663:               
664:               // CCPM 4th rising edge; EN disabled; FMT right_aligned; 
665:               CCP1CON = 0x6;
0AB7  3006     MOVLW 0x6
0AB8  0147     MOVLB 0x7
0AB9  008E     MOVWF CCP1CON
666:               
667:               // CTS CCP1PPS; 
668:               CCP1CAP = 0x0;
0ABA  018F     CLRF CCP1CAP
669:               
670:               // CCPRH 0; 
671:               CCPR1H = 0x0;
0ABB  018D     CLRF CCPR1H
672:               
673:               // CCPRL 0; 
674:               CCPR1L = 0x0;
0ABC  018C     CLRF CCPR1
675:           
676:           
677:               // Selecting Timer 1
678:               CCPTMRS0bits.C1TSEL = 0x1;
0ABD  081F     MOVF CCPTMRS0, W
0ABE  39FC     ANDLW 0xFC
0ABF  3801     IORLW 0x1
0AC0  009F     MOVWF CCPTMRS0
679:           }
0AC1  0008     RETURN
680:           uint16_t CCP1_CaptureRead(void){
681:               CCPR1_PERIOD_REG_T module;
682:           
683:               // Copy captured value.
684:               module.ccpr1l = CCPR1L;
0B36  0147     MOVLB 0x7
0B37  080C     MOVF CCPR1, W
0B38  00F2     MOVWF 0x3F2
0B39  0872     MOVF 0x3F2, W
0B3A  00F3     MOVWF 0x3F3
685:               module.ccpr1h = CCPR1H;
0B3B  080D     MOVF CCPR1H, W
0B3C  00F2     MOVWF 0x3F2
0B3D  0872     MOVF 0x3F2, W
0B3E  00F4     MOVWF 0x3F4
686:               
687:               // Return 16bit captured value
688:               return module.ccpr1_16Bit;
0B3F  0874     MOVF 0x3F4, W
0B40  00F1     MOVWF 0x3F1
0B41  0873     MOVF 0x3F3, W
0B42  00F0     MOVWF 0x3F0
689:           }
0B43  0008     RETURN
690:           
691:               //CCP2 Functions and Declarations
692:           void CCP2_Initialize(void) {
693:               // Set the CCP2 to the options selected in the User Interface
694:               
695:               // CCPM Every edge; EN disabled; FMT right_aligned; 
696:               CCP2CON = 0x3;
0AC2  3003     MOVLW 0x3
0AC3  0147     MOVLB 0x7
0AC4  0092     MOVWF CCP2CON
697:               
698:               // CTS CCP2PPS; 
699:               CCP2CAP = 0x0;
0AC5  0193     CLRF CCP2CAP
700:               
701:               // CCPRH 0; 
702:               CCPR2H = 0x0;
0AC6  0191     CLRF CCPR2H
703:               
704:               // CCPRL 0; 
705:               CCPR2L = 0x0;
0AC7  0190     CLRF CCPR2
706:           
707:           
708:               // Selecting Timer 1
709:               CCPTMRS0bits.C2TSEL = 0x1;
0AC8  081F     MOVF CCPTMRS0, W
0AC9  39F3     ANDLW 0xF3
0ACA  3804     IORLW 0x4
0ACB  009F     MOVWF CCPTMRS0
710:           }
0ACC  0008     RETURN
711:           uint16_t CCP2_CaptureRead(void){
712:               CCPR2_PERIOD_REG_T module;
713:           
714:               // Copy captured value.
715:               module.ccpr2l = CCPR2L;
0B44  0147     MOVLB 0x7
0B45  0810     MOVF CCPR2, W
0B46  00F2     MOVWF 0x3F2
0B47  0872     MOVF 0x3F2, W
0B48  00F3     MOVWF 0x3F3
716:               module.ccpr2h = CCPR2H;
0B49  0811     MOVF CCPR2H, W
0B4A  00F2     MOVWF 0x3F2
0B4B  0872     MOVF 0x3F2, W
0B4C  00F4     MOVWF 0x3F4
717:               
718:               // Return 16bit captured value
719:               return module.ccpr2_16Bit;
0B4D  0874     MOVF 0x3F4, W
0B4E  00F1     MOVWF 0x3F1
0B4F  0873     MOVF 0x3F3, W
0B50  00F0     MOVWF 0x3F0
720:           }
0B51  0008     RETURN
721:           
722:           //Initialization Functions
723:           
724:           void Timer1_Gate_Initialize(void){
725:               T1GPPS = 0xD; //RB5->TMR1:T1G;
0AA7  300D     MOVLW 0xD
0AA8  017C     MOVLB 0x3C
0AA9  0090     MOVWF T1GPPS
726:               
727:               Timer1_Initialize_Timer1Gate(); 
0AAA  318E     MOVLP 0xE
0AAB  2631     CALL 0x631
0AAC  318A     MOVLP 0xA
728:           }
0AAD  0008     RETURN
729:           void CLC_NCO1_Initialize(void){
730:               T1CON = 0x0;
0C39  0145     MOVLB 0x5
0C3A  018E     CLRF T1CON
731:               NCO1_Initialize_CLCNCO1_CLCNCO2();
0C3B  318A     MOVLP 0xA
0C3C  22F9     CALL 0x2F9
0C3D  318C     MOVLP 0xC
732:               CLC1_Initialize_CLCNCO1();
0C3E  318E     MOVLP 0xE
0C3F  2650     CALL 0x650
0C40  318C     MOVLP 0xC
733:               CLC2_Initialize_CLCNCO1();
0C41  318C     MOVLP 0xC
0C42  2424     CALL 0x424
0C43  318C     MOVLP 0xC
734:               Timer1_Initialize_CLCNCO1();
0C44  318D     MOVLP 0xD
0C45  2544     CALL 0x544
0C46  318C     MOVLP 0xC
735:               CLC_NCO1_Pins_PPS();
0C47  318C     MOVLP 0xC
0C48  24A6     CALL 0x4A6
0C49  318C     MOVLP 0xC
736:               setup_for_new_measurement_CLCNCO1(); 
0C4A  318B     MOVLP 0xB
0C4B  2361     CALL 0x361
0C4C  318C     MOVLP 0xC
737:           }
0C4D  0008     RETURN
738:           void CLC_NCO2_Initialize(void){
739:               T1CON = 0x0;//
0C8E  0145     MOVLB 0x5
0C8F  018E     CLRF T1CON
740:               NCO1_Initialize_CLCNCO1_CLCNCO2();//
0C90  318A     MOVLP 0xA
0C91  22F9     CALL 0x2F9
0C92  318C     MOVLP 0xC
741:               CLC1_Initialize_CLCNCO2();
0C93  318E     MOVLP 0xE
0C94  2671     CALL 0x671
0C95  318C     MOVLP 0xC
742:               CLC2_Initialize_CLCNCO2();
0C96  318B     MOVLP 0xB
0C97  23D8     CALL 0x3D8
0C98  318C     MOVLP 0xC
743:               CLC3_Initialize_CLCNCO2();
0C99  318C     MOVLP 0xC
0C9A  244E     CALL 0x44E
0C9B  318C     MOVLP 0xC
744:               Timer1_Initialize_CLCNCO2();
0C9C  318C     MOVLP 0xC
0C9D  24D8     CALL 0x4D8
0C9E  318C     MOVLP 0xC
745:               CLC_NCO2_Pins_PPS();
0C9F  318D     MOVLP 0xD
0CA0  257C     CALL 0x57C
0CA1  318C     MOVLP 0xC
746:               setup_for_new_measurement_CLCNCO2(); 
0CA2  318B     MOVLP 0xB
0CA3  23A1     CALL 0x3A1
0CA4  318C     MOVLP 0xC
747:           }
0CA5  0008     RETURN
748:           void CLC_NCO3_Initialize(void){
749:               T1CON = 0x0;
0D0E  0145     MOVLB 0x5
0D0F  018E     CLRF T1CON
750:               NCO1_Initialize_CLCNCO3();
0D10  318B     MOVLP 0xB
0D11  2329     CALL 0x329
0D12  318D     MOVLP 0xD
751:               CLC1_Initialize_CLCNCO3();
0D13  318E     MOVLP 0xE
0D14  2692     CALL 0x692
0D15  318D     MOVLP 0xD
752:               CLC2_Initialize_CLCNCO3();
0D16  318B     MOVLP 0xB
0D17  23FE     CALL 0x3FE
0D18  318D     MOVLP 0xD
753:               CLC3_Initialize_CLCNCO3();
0D19  318C     MOVLP 0xC
0D1A  2463     CALL 0x463
0D1B  318D     MOVLP 0xD
754:               Timer0_Initialize_CLCNCO3();
0D1C  318B     MOVLP 0xB
0D1D  23B3     CALL 0x3B3
0D1E  318D     MOVLP 0xD
755:               Timer1_Initialize_CLCNCO3();
0D1F  318C     MOVLP 0xC
0D20  24F3     CALL 0x4F3
0D21  318D     MOVLP 0xD
756:               CLC_NCO3_Pins_PPS();
0D22  318C     MOVLP 0xC
0D23  24BF     CALL 0x4BF
0D24  318D     MOVLP 0xD
757:               setup_for_new_measurement_CLCNCO3();
0D25  318B     MOVLP 0xB
0D26  23EB     CALL 0x3EB
0D27  318D     MOVLP 0xD
758:           }
0D28  0008     RETURN
759:           void CCP_Initialize(void){
760:               
761:               CCP1_Initialize();
0BC5  318A     MOVLP 0xA
0BC6  22B7     CALL 0x2B7
0BC7  318B     MOVLP 0xB
762:               CCP2_Initialize();        
0BC8  318A     MOVLP 0xA
0BC9  22C2     CALL 0x2C2
0BCA  318B     MOVLP 0xB
763:               
764:               CCP2PPS = 0xD;  //RB5->CCP2:CCP2;
0BCB  300D     MOVLW 0xD
0BCC  017C     MOVLB 0x3C
0BCD  009F     MOVWF CCP2PPS
765:               RB5PPS = 0x0A;  //RB5->CCP1:CCP1;
0BCE  300A     MOVLW 0xA
0BCF  017B     MOVLB 0x3B
0BD0  0099     MOVWF RB5PPS
766:               CCP1PPS = 0xD;  //RB5->CCP1:CCP1;
0BD1  300D     MOVLW 0xD
0BD2  017C     MOVLB 0x3C
0BD3  009E     MOVWF CCP1PPS
767:               
768:               
769:               PIR2bits.CCP1IF = 0;
0BD4  0141     MOVLB 0x1
0BD5  110E     BCF PIR2, 0x2
770:               PIR2bits.CCP2IF = 0;
0BD6  118E     BCF PIR2, 0x3
771:               
772:           }
0BD7  0008     RETURN
773:           void IOC_w_Timer_Initialize(void){
774:               IOCBP = 0x20;
0AAE  3020     MOVLW 0x20
0AAF  017D     MOVLB 0x3D
0AB0  009B     MOVWF IOCBP
775:               IOCBN = 0x20;    
0AB1  3020     MOVLW 0x20
0AB2  009C     MOVWF IOCBN
776:               Timer0_Initialize();
0AB3  318D     MOVLP 0xD
0AB4  2529     CALL 0x529
0AB5  318A     MOVLP 0xA
777:           }
0AB6  0008     RETURN
778:           void IOC_wo_Timer_Initialize(void){
779:               IOCBP = 0x20;
0A82  3020     MOVLW 0x20
0A83  017D     MOVLB 0x3D
0A84  009B     MOVWF IOCBP
780:               IOCBN = 0x20;
0A85  3020     MOVLW 0x20
0A86  009C     MOVWF IOCBN
781:           }
0A87  0008     RETURN
782:           
783:           //Pins and PPS Functions
784:           
785:           void CLC_NCO1_Pins_PPS(void){
786:               TRISA = 0xDF;//
0CA6  30DF     MOVLW 0xDF
0CA7  0140     MOVLB 0x0
0CA8  0092     MOVWF TRISA
787:               TRISC = 0xBB;//
0CA9  30BB     MOVLW 0xBB
0CAA  0094     MOVWF TRISC
788:               
789:               ANSELA = 0xD8;//
0CAB  30D8     MOVLW 0xD8
0CAC  017D     MOVLB 0x3D
0CAD  008C     MOVWF ANSELA
790:               ANSELC = 0x3A;//
0CAE  303A     MOVLW 0x3A
0CAF  00A0     MOVWF ANSELC
791:           
792:               RA5PPS = 0x01;  //RA5->CLC1:CLC1OUT;
0CB0  3001     MOVLW 0x1
0CB1  017B     MOVLB 0x3B
0CB2  0091     MOVWF RA5PPS
793:               RC2PPS = 0x02;  //RC2->CLC2:CLC2OUT;
0CB3  3002     MOVLW 0x2
0CB4  009E     MOVWF RC2PPS
794:               T1CKIPPS = 0x10; //RC0->TMR1:T1CKI;
0CB5  3010     MOVLW 0x10
0CB6  017C     MOVLB 0x3C
0CB7  008F     MOVWF T1CKIPPS
795:               T1GPPS = 0xD; //RB5->TMR1:T1G;
0CB8  300D     MOVLW 0xD
0CB9  0090     MOVWF T1GPPS
796:               CLCIN0PPS = 0x2; //RA2->CLC1:CLCIN0;
0CBA  3002     MOVLW 0x2
0CBB  00BD     MOVWF CLCIN0PPS
797:               CLCIN1PPS = 0x1; //RA1->CLC2:CLCIN1;
0CBC  3001     MOVLW 0x1
0CBD  00BE     MOVWF CLCIN1PPS
798:           }
0CBE  0008     RETURN
799:           void CLC_NCO2_Pins_PPS(void){
800:               TRISA = 0xDF;
0D7C  30DF     MOVLW 0xDF
0D7D  0140     MOVLB 0x0
0D7E  0092     MOVWF TRISA
801:               TRISB = 0xFD;
0D7F  30FD     MOVLW 0xFD
0D80  0093     MOVWF TRISB
802:               TRISC = 0xBB;
0D81  30BB     MOVLW 0xBB
0D82  0094     MOVWF TRISC
803:               
804:               ANSELA = 0xDA;
0D83  30DA     MOVLW 0xDA
0D84  017D     MOVLB 0x3D
0D85  008C     MOVWF ANSELA
805:               ANSELB = 0xD1;
0D86  30D1     MOVLW 0xD1
0D87  0096     MOVWF ANSELB
806:               ANSELC = 0x3B;
0D88  303B     MOVLW 0x3B
0D89  00A0     MOVWF ANSELC
807:               
808:               RA5PPS = 0x01;  //RA5->CLC1:CLC1OUT;
0D8A  3001     MOVLW 0x1
0D8B  017B     MOVLB 0x3B
0D8C  0091     MOVWF RA5PPS
809:               RC2PPS = 0x02;  //RC2->CLC2:CLC2OUT;
0D8D  3002     MOVLW 0x2
0D8E  009E     MOVWF RC2PPS
810:               T1CKIPPS = 0x10; //RC0->TMR1:T1CKI;
0D8F  3010     MOVLW 0x10
0D90  017C     MOVLB 0x3C
0D91  008F     MOVWF T1CKIPPS
811:               T1GPPS = 0xD; //RB5->TMR1:T1G;
0D92  300D     MOVLW 0xD
0D93  0090     MOVWF T1GPPS
812:               CLCIN0PPS = 0x2; //RA2->CLC1:CLCIN0;
0D94  3002     MOVLW 0x2
0D95  00BD     MOVWF CLCIN0PPS
813:               CLCIN1PPS = 0x1; //RA1->CLC2:CLCIN1;
0D96  3001     MOVLW 0x1
0D97  00BE     MOVWF CLCIN1PPS
814:           }
0D98  0008     RETURN
815:           void CLC_NCO3_Pins_PPS(void){
816:               TRISA = 0xDF;
0CBF  30DF     MOVLW 0xDF
0CC0  0140     MOVLB 0x0
0CC1  0092     MOVWF TRISA
817:               TRISB = 0xFD;
0CC2  30FD     MOVLW 0xFD
0CC3  0093     MOVWF TRISB
818:               TRISC = 0xBB;
0CC4  30BB     MOVLW 0xBB
0CC5  0094     MOVWF TRISC
819:               
820:               ANSELA = 0xDA;
0CC6  30DA     MOVLW 0xDA
0CC7  017D     MOVLB 0x3D
0CC8  008C     MOVWF ANSELA
821:               ANSELB = 0xDD;
0CC9  30DD     MOVLW 0xDD
0CCA  0096     MOVWF ANSELB
822:               ANSELC = 0x3B;
0CCB  303B     MOVLW 0x3B
0CCC  00A0     MOVWF ANSELC
823:               
824:               RA5PPS = 0x01;  //RA5->CLC1:CLC1OUT;
0CCD  3001     MOVLW 0x1
0CCE  017B     MOVLB 0x3B
0CCF  0091     MOVWF RA5PPS
825:               RC2PPS = 0x02;  //RC2->CLC2:CLC2OUT;
0CD0  3002     MOVLW 0x2
0CD1  009E     MOVWF RC2PPS
826:               RB1PPS = 0x03;  //RB1->CLC3:CLC3OUT;
0CD2  3003     MOVLW 0x3
0CD3  0095     MOVWF RB1PPS
827:               CLCIN0PPS = 0x2; //RA2->CLC1:CLCIN0;
0CD4  3002     MOVLW 0x2
0CD5  017C     MOVLB 0x3C
0CD6  00BD     MOVWF CLCIN0PPS
828:           }
0CD7  0008     RETURN
829:           
830:           //Reset-Clear Functions
831:           
832:           void TMR0_Reset(void){
833:               TMR0H = 0xFF;
0AA0  30FF     MOVLW 0xFF
0AA1  0143     MOVLB 0x3
0AA2  009D     MOVWF TMR0H
834:               TMR0L = 0x0;
0AA3  019C     CLRF TMR0L
835:               T0CON1 = 0x0;
0AA4  019F     CLRF T0CON1
836:               T0CON0 = 0x0;
0AA5  019E     CLRF T0CON0
837:           }
0AA6  0008     RETURN
838:           void TMR1_Reset(void){
839:               T1GCON = 0x0;
840:               T1GATE = 0x0;
841:               T1CLK = 0x0;
842:               TMR1H = 0x0;
843:               TMR1L = 0x0;
844:           }
845:           void CLC1_Reset(void){
846:               CLCSELECT = 0x0;
847:               CLCnPOL = 0x0;
848:               CLCnSEL0 = 0x0;
849:               CLCnSEL1 = 0x0;
850:               CLCnSEL2 = 0x0;
851:               CLCnSEL3 = 0x0;
852:               CLCnGLS0 = 0x0;
853:               CLCnGLS1 = 0x0;
854:               CLCnGLS2 = 0x0;
855:               CLCnGLS3 = 0x0;
856:               CLCDATA = 0x0;
857:               CLCnCON = 0x0;
858:           }
859:           void CLC2_Reset(void){
860:               CLCSELECT = 0x1;
861:               CLCnPOL = 0x0;
862:               CLCnSEL0 = 0x0;
863:               CLCnSEL1 = 0x0;
864:               CLCnSEL2 = 0x0;
865:               CLCnSEL3 = 0x0;
866:               CLCnGLS0 = 0x0;
867:               CLCnGLS1 = 0x0;
868:               CLCnGLS2 = 0x0;
869:               CLCnGLS3 = 0x0;
870:               CLCDATA = 0x0;
871:               CLCnCON = 0x0;
872:           }
873:           void CLC3_Reset(void){
874:               CLCSELECT = 0x2;
875:               CLCnPOL = 0x0;
876:               CLCnSEL0 = 0x0;
877:               CLCnSEL1 = 0x0;
878:               CLCnSEL2 = 0x0;
879:               CLCnSEL3 = 0x0;
880:               CLCnGLS0 = 0x0;
881:               CLCnGLS1 = 0x0;
882:               CLCnGLS2 = 0x0;
883:               CLCnGLS3 = 0x0;
884:               CLCDATA = 0x0;
885:               CLCnCON = 0x0;
886:           }
887:           void IOC_Reset(void){
888:               IOCBP = 0x00;
07FC  017D     MOVLB 0x3D
07FD  019B     CLRF IOCBP
889:               IOCBN = 0x00;
07FE  019C     CLRF IOCBN
890:           }
07FF  0008     RETURN
891:           void Pins_PPS_Reset(void){
892:               PIN_MANAGER_Initialize();
0B80  3187     MOVLP 0x7
0B81  271C     CALL 0x71C
0B82  318B     MOVLP 0xB
893:               RA5PPS = 0x0;  //Reset RA5
0B83  017B     MOVLB 0x3B
0B84  0191     CLRF RA5PPS
894:               RB1PPS = 0x0;  //Reset RB1
0B85  0195     CLRF RB1PPS
895:               RC2PPS = 0x0;  //Reset RC2
0B86  019E     CLRF RC2PPS
896:               T1CKIPPS = 0x10; //Reset T1CK
0B87  3010     MOVLW 0x10
0B88  017C     MOVLB 0x3C
0B89  008F     MOVWF T1CKIPPS
897:               T1GPPS = 0xD; //Reset T1G
0B8A  300D     MOVLW 0xD
0B8B  0090     MOVWF T1GPPS
898:               CLCIN0PPS = 0x0; //Reset CLCIN0
0B8C  01BD     CLRF CLCIN0PPS
899:               CLCIN1PPS = 0x1; //Reset CLCIN1
0B8D  3001     MOVLW 0x1
0B8E  00BE     MOVWF CLCIN1PPS
900:           }
0B8F  0008     RETURN
